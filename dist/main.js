/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/combatant.js":
/*!**************************!*\
  !*** ./src/combatant.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Combatant; }\n/* harmony export */ });\nclass Combatant {\n    constructor() {\n        this.animationState = \"idle\"\n        this.animations = [];\n        this.animationQueue = []\n        this.animationTripper = -1\n        this.attack = 0\n        this.block = 0\n        this.aniPlaying = false\n        this.aniCheckQueue = []\n    }\n\n    animationFramesSetter() {\n        this.animationStates.forEach((spriteState) => {\n            let frames = {\n                loc: [],\n                src: spriteState.src\n            }\n            for (let j = 0; j < spriteState.frames; j++) {\n                let positionX = j * this.spriteWidth;\n                let positionY = 0;\n                frames.loc.push({ x: positionX, y: positionY });\n            }\n            this.animations[spriteState.name] = frames;\n        });\n    }\n\n    draw(ctx, gameFrame, staggerFrames, heightOffset) {\n\n        let rawPosition = (gameFrame / staggerFrames) % this.animations[this.animationState].loc.length\n        let position = Math.floor(rawPosition)\n        if (this.constructor.name === \"Knight\") console.log(this.spriteWidth * position)\n        let frameX = this.spriteWidth * position;\n        let frameY = 0\n        ctx.drawImage(this.image, 0, 0, this.spriteWidth, this.spriteHeight, this.xPosition, this.yPosition - heightOffset, Math.floor(this.spriteWidth * this.sizeCoef), Math.floor(this.spriteHeight * this.sizeCoef))\n\n        if (this.animationState !== \"dead\") {\n            if (this.animationState !== \"idle\") {\n                this.aniCheckQueue.push(position)\n                let unique = this.aniCheckQueue.filter((value, index, self) => { return self.indexOf(value) === index })\n                if (unique.length > 1 && this.aniCheckQueue.at(-1) === 0 && this.animationState !== \"idle\") {\n                    this.animationQueueSetter()\n                    this.aniCheckQueue = []\n                    position = 0\n                    gameFrame = 0\n                }\n            \n            }\n            // console.log(this.animationQueue)\n            if (this.animationQueue.length > 0 && this.animationState === \"idle\") {\n                this.animationQueueSetter()\n                position = 0\n                gameFrame = 0\n            }\n        }   \n\n    }\n\n    heal(healVal) {\n        if (this.health + healVal > this.maxHealth) {\n            this.health = this.maxHealth\n        } else {\n            this.health += healVal\n        }\n    }\n\n    animationQueueSetter() {\n        if (this.animationQueue.length === 0) {\n            this.animation(\"idle\")\n        } else {\n            let aniStateName = this.animationQueue.shift()\n            if (this.constructor.name === \"Knight\") console.log(aniStateName)\n            this.animation(aniStateName)\n        } \n    }\n\n    framesFinder(aniStateName) {\n        for (let i in this.animationStates) {\n            let frameObj = this.animationStates[i]\n            if (frameObj[\"name\"] === aniStateName) return frameObj[\"frames\"]\n        }\n    }\n\n    animation = function(aniStateName) {\n        this.animationState = aniStateName\n        this.image.src = this.animations[aniStateName].src\n    }\n\n}\n\n\n\nCombatant.prototype.runForwards = function () {\n    this.xPosition += 1.12\n    this.yPosition = 400\n}\n\n\n//# sourceURL=webpack://jsproj/./src/combatant.js?");

/***/ }),

/***/ "./src/crowd.js":
/*!**********************!*\
  !*** ./src/crowd.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Crowd; }\n/* harmony export */ });\nclass Crowd {\r\n    constructor(heightOffset) {\r\n        this.heightOffset = heightOffset\r\n        this.leftImg = new Image()\r\n        this.leftImg.src = './dist/art/crowd_left.png'\r\n        this.rightImg = new Image()\r\n        this.rightImg.src = './dist/art/crowd_right.png'\r\n        this.crowdArray = []\r\n        this.excitement = 75\r\n        this.populateSection()\r\n        this.updateYImmediate(heightOffset)\r\n        this.calmDown() \r\n    }\r\n\r\n    sectionBoundaries() {\r\n        return { \r\n            farLeft: {\r\n                xLow: 0,\r\n                xHigh: 120,\r\n                yLow: 350,\r\n                yHigh: 415,\r\n                spectArr: [],\r\n                img: this.rightImg,\r\n                size: 38,\r\n                pop: 10\r\n            },\r\n            midLeft: {\r\n                xLow: 240,\r\n                xHigh: 400,\r\n                yLow: 360,\r\n                yHigh: 400,\r\n                spectArr: [],\r\n                img: this.rightImg,\r\n                size: 38,\r\n                pop: 10\r\n            },\r\n            midRight: {\r\n                xLow: 500,\r\n                xHigh: 680,\r\n                yLow: 360,\r\n                yHigh: 400,\r\n                spectArr: [],\r\n                img: this.leftImg,\r\n                size: 38,\r\n                pop: 10\r\n            },\r\n            farRight: {\r\n                xLow: 780,\r\n                xHigh: 900,\r\n                yLow: 350,\r\n                yHigh: 415,\r\n                spectArr: [],\r\n                img: this.leftImg,\r\n                size: 38,\r\n                pop: 10\r\n            },\r\n            midRightBalc: {\r\n                xLow: 500,\r\n                xHigh: 660,\r\n                yLow: 275,\r\n                yHigh: 300,\r\n                spectArr: [],\r\n                img: this.leftImg,\r\n                size: 25,\r\n                pop: 15\r\n            },\r\n            midleftBalc: {\r\n                xLow: 300,\r\n                xHigh: 490,\r\n                yLow: 275,\r\n                yHigh: 300,\r\n                spectArr: [],\r\n                img: this.rightImg,\r\n                size: 25,\r\n                pop: 15\r\n            },\r\n            farleftBalc: {\r\n                xLow: 10,\r\n                xHigh: 300,\r\n                yLow: 260,\r\n                yHigh: 278,\r\n                spectArr: [],\r\n                img: this.rightImg,\r\n                size: 25,\r\n                pop: 15\r\n            },\r\n            farrightBalc: {\r\n                xLow: 600,\r\n                xHigh: 900,\r\n                yLow: 260,\r\n                yHigh: 278,\r\n                spectArr: [],\r\n                img: this.leftImg,\r\n                size: 25,\r\n                pop: 15\r\n            },\r\n            midrightNosebleed: {\r\n                xLow: 400,\r\n                xHigh: 700,\r\n                yLow: 185,\r\n                yHigh: 200,\r\n                spectArr: [],\r\n                img: this.leftImg,\r\n                size: 18,\r\n                pop: 20\r\n            }, \r\n            midleftNosebleed: {\r\n                xLow: 200,\r\n                xHigh: 500,\r\n                yLow: 185,\r\n                yHigh: 200,\r\n                spectArr: [],\r\n                img: this.rightImg,\r\n                size: 18,\r\n                pop: 20\r\n            }, \r\n            farleftNosebleed: {\r\n                xLow: 100,\r\n                xHigh: 400,\r\n                yLow: 170,\r\n                yHigh: 180,\r\n                spectArr: [],\r\n                img: this.rightImg,\r\n                size: 18,\r\n                pop: 12\r\n            },\r\n            farrightNosebleed: {\r\n                xLow: 500,\r\n                xHigh: 800,\r\n                yLow: 170,\r\n                yHigh: 180,\r\n                spectArr: [],\r\n                img: this.leftImg,\r\n                size: 18,\r\n                pop: 12\r\n            }, \r\n\r\n            \r\n        }\r\n\r\n    }\r\n\r\n    populateSection() {\r\n        let allSections = this.sectionBoundaries()\r\n        for (let sectionName in allSections) {\r\n            let section = allSections[sectionName]\r\n            let xRange = section[\"xHigh\"] - section[\"xLow\"]\r\n            let yRange = section[\"yHigh\"] - section[\"yLow\"]\r\n            for (let i = 0; i <= section[\"pop\"]; i++) {\r\n                let dude = { img: section[\"img\"] }\r\n                let yStart = Math.floor(Math.random() * yRange) + section[\"yLow\"]\r\n                dude[\"yRender\"] = yStart\r\n                dude[\"yCore\"] = yStart\r\n                dude[\"xRender\"] = Math.floor(Math.random() * xRange) + section[\"xLow\"]\r\n                dude[\"sizeX\"] = Math.floor(Math.random() * 10) + section[\"size\"]\r\n                dude[\"sizeY\"] = Math.floor(Math.random() * 10) + section[\"size\"]\r\n                section[\"spectArr\"].push(dude)\r\n            }\r\n            section[\"spectArr\"].sort((a, b) => { return a[\"posY\"] - b[\"posY\"]})\r\n            this.crowdArray.push(section)\r\n        }\r\n      }\r\n\r\n    jostle() {\r\n        for (let i = 0; i < this.crowdArray.length; i++) {\t\r\n            let section = this.crowdArray[i][\"spectArr\"]\r\n            let sectionRules = this.crowdArray[i]\r\n            let xHigh = sectionRules[\"xHigh\"]\r\n            let xLow = sectionRules[\"xLow\"]\r\n            let yHigh = sectionRules[\"yHigh\"]\r\n            let yLow = sectionRules[\"yLow\"]\r\n\r\n            for (let j = 0; j < section.length; j++) {\t\r\n                let yStagger = Math.floor(Math.random() * this.excitement)\r\n                let xStagger = Math.floor(Math.random() * (this.excitement + 10))\r\n                if (yStagger === 0) {\r\n                    let spectator = section[j]\r\n                    \r\n                        spectator[\"yCore\"] += Math.floor(Math.random() * 3) - 1\r\n                        if (xStagger === 0) spectator[\"xRender\"] += Math.floor(Math.random() * 3) - 1\r\n                        if (spectator[\"yCore\"] > sectionRules[\"yHigh\"]) {\r\n                            spectator[\"yCore\"] = yHigh\r\n                        } \r\n                        if (spectator[\"yCore\"] < sectionRules[\"yLow\"]) {\r\n                            spectator[\"yCore\"] = yLow\r\n                        }\r\n                        if (spectator[\"xRender\"] > sectionRules[\"xHigh\"]) {\r\n                            spectator[\"xRender\"] = xHigh\r\n                        }\r\n                    if (spectator[\"xRender\"] < sectionRules[\"xLow\"]) {\r\n                        spectator[\"xRender\"] = xLow\r\n                        }\r\n        \r\n                        \r\n                    }\r\n            }\r\n            section.sort((a, b) => { return a[\"posY\"] - b[\"posY\"] })\r\n\r\n       } \r\n    }\r\n\r\n    calmDown() {\r\n        setInterval(()=>{\r\n            if (this.excitement < 75) this.excitement += 1\r\n        }, 1000)\r\n    }\r\n\r\n    excite(num) {\r\n        this.excitement = num\r\n    }\r\n\r\n\r\n    hush() {\r\n        this.excitement = 75\r\n    }\r\n\r\n    updateYImmediate(heightOffset) {\r\n        for (let i = 0; i < this.crowdArray.length; i++) {\r\n            let section = this.crowdArray[i][\"spectArr\"]\r\n\r\n            for (let j = 0; j < section.length; j++) {\r\n                let spectator = section[j]\r\n                spectator[\"yRender\"] = spectator[\"yCore\"] - heightOffset\r\n                spectator[\"yRender\"] = spectator[\"yCore\"] - heightOffset\r\n            }\r\n            section.sort((a, b) => { return a[\"yRender\"] - b[\"yRender\"] })\r\n\r\n        } \r\n    }\r\n\r\n\r\n\r\n}\n\n//# sourceURL=webpack://jsproj/./src/crowd.js?");

/***/ }),

/***/ "./src/deck.js":
/*!*********************!*\
  !*** ./src/deck.js ***!
  \*********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Deck; }\n/* harmony export */ });\nclass Deck {\r\n    constructor(combatant, decksize) { \r\n        this.combatant = combatant\r\n        this.stack = []\r\n        this.allUniqueCards = {}\r\n        this.deckMaker(decksize)\r\n        this.graveyard = 0\r\n\r\n        this.fullDeck = new Image()\r\n        this.fullDeck.src = \"./dist/art/deck/full_deck.png\"\r\n\r\n        this.halfDeck = new Image()\r\n        this.halfDeck.src = \"./dist/art/deck/half_deck.png\"\r\n\r\n        this.emptyDeck = new Image()\r\n        this.emptyDeck.src = \"./dist/art/deck/empty_deck.png\"\r\n    }\r\n\r\n\r\n    deckMaker(decksize) {\r\n        let infiniteDeck;\r\n        let cardStats;\r\n        \r\n        if (this.combatant.name === \"Knight\") {\r\n            cardStats = this.playerCards(this.combatant)\r\n            infiniteDeck = false\r\n        } else {\r\n            cardStats = this.opponentCards(this.combatant)\r\n            infiniteDeck = true\r\n        }\r\n        let allCardNames = Object.keys(cardStats)\r\n\r\n        for (let i = 0; i < allCardNames.length; i++) {\r\n            let card = cardStats[allCardNames[i]]\r\n            let img = new Image()\r\n            img.src = card.src\r\n            card.art = img\r\n            this.allUniqueCards[allCardNames[i]] = card\r\n        }\r\n\r\n        for (let i = 0; i < decksize; i++) {\r\n            let card;\r\n            if (infiniteDeck) {\r\n                let allUniqueCardkeys = Object.keys(this.allUniqueCards)\r\n                card = this.allUniqueCards[allUniqueCardkeys[allUniqueCardkeys.length * Math.random() << 0]]\r\n            } else {\r\n                card = this.allUniqueCards[allCardNames[i]]\r\n            }\r\n            this.stack.push(card)\r\n        }\r\n\r\n        if (!infiniteDeck) {\r\n            this.shuffleDeck()\r\n        } else {\r\n            this.pruneDeck()\r\n        }\r\n    }\r\n\r\n    pruneDeck() {\r\n        let resetStack = []\r\n        let bF = this.allUniqueCards[\"blindingFlash\"]\r\n        let gP = this.allUniqueCards[\"groundPound\"]\r\n        let interval;\r\n\r\n        for (let i = 0; i < this.stack.length - 3; i++) {\t\r\n            let card = this.stack[i]\r\n            if (interval && card === bF) {\r\n                interval--\r\n                continue\r\n            } else {\r\n                if (card === bF) interval = 3\r\n                resetStack.push(card)\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < resetStack.length - 3; i++) {\r\n            let card = resetStack[i]\r\n            if (interval && card === gP) {\r\n                interval--\r\n                continue\r\n            } else {\r\n                if (card === gP) interval = 3\r\n                this.stack.unshift(card)\r\n            }\r\n        }\r\n    }\r\n\r\n    shuffleDeck() {\r\n        for (let i = this.stack.length - 1; i > 0; i--) {\r\n            const j = Math.floor(Math.random() * (i + 1));\r\n            const temp = this.stack[i];\r\n            this.stack[i] = this.stack[j];\r\n            this.stack[j] = temp;\r\n        }\r\n    }\r\n\r\n    playerCards(knight) {\r\n        \r\n        return {\r\n            strike: {\r\n                id: \"strike\",\r\n                attack: function() { return 4 },\r\n                block: function () { return 0 },\r\n                src: \"./dist/art/knight_cards/strike.png\",\r\n                animation: \"attack\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            defend: {\r\n                id: \"defend\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 5 },\r\n                src: \"./dist/art/knight_cards/defend.png\",\r\n                animation: \"attack2\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            reposition: {\r\n                id: \"reposition\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 2 },\r\n                src: \"./dist/art/knight_cards/reposition.png\",\r\n                animation: \"duck\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { \r\n                    this.numCardsDraw += 1 \r\n                } // draw a card\r\n            },\r\n\r\n            taunt: {\r\n                id: \"taunt\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 4 },\r\n                src: \"./dist/art/knight_cards/taunt.png\",\r\n                animation: \"duck\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { \r\n                    this.opponent.nextMove[1] = this.opponent.allUniqueCards[\"strike\"]\r\n                } // your opponent must use strike next turn\r\n            },\r\n\r\n            parry: {\r\n                id: \"parry\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 0 },\r\n                src: \"./dist/art/knight_cards/parry.png\",\r\n                animation: \"combo\",\r\n                instantEffects: function () {\r\n                if (this.opponentCard.attack) {\r\n                    this.opponentCard.attack = function () { return 0 }\r\n                    this.opponent.health -= 4\r\n                    this.numCardsDraw += 1 \r\n                }\r\n                 },\r\n                delayedEffects: function () { \r\n                } // If your opponent attacks this turn, you negate the attack and they take 4 damage.\r\n            },\r\n\r\n            shieldShatter: {\r\n                id: \"shieldShatter\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 0 },\r\n                src: \"./dist/art/knight_cards/shield_shatter.png\",\r\n                animation: \"attack2\",\r\n                instantEffects: function () {\r\n                    this.opponent.health -= (this.opponentCard.block() * 2)\r\n                    this.numCardsDraw += 1\r\n                },\r\n                delayedEffects: function () {\r\n                } // deal damage equal to twice your opponent's block\r\n            },\r\n\r\n            shieldOfFaith: {\r\n                id: \"shieldOfFaith\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 5 },\r\n                src: \"./dist/art/knight_cards/shield_of_faith.png\",\r\n                animation: \"attack2\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { \r\n                    this.knight.status[\"damageImmune\"] = true\r\n                    this.knight.status[\"ttdamageImmune\"] = 1\r\n                } //You take no damage next turn\r\n            },\r\n\r\n            dodge: {\r\n                id: \"dodge\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 0 },\r\n                src: \"./dist/art/knight_cards/dodge.png\",\r\n                animation:  \"roll\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { \r\n                    if (this.opponent.attack > this.knight.block) this.knight.health += (this.opponent.attack - this.knight.block)\r\n                } //You take no damage this turn\r\n            },\r\n\r\n            secondWind: {\r\n                id: \"secondWind\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 8 },\r\n                src: \"./dist/art/knight_cards/second_wind.png\",\r\n                animation: \"duck\",\r\n                instantEffects: function () { \r\n                    this.knight.heal(8)\r\n                },\r\n                delayedEffects: function () { \r\n                    this.numCardsDraw += 1 \r\n                } //recover 8 health, draw a card\r\n            },\r\n\r\n            feint: {\r\n                id: \"feint\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 0 },\r\n                src: \"./dist/art/knight_cards/feint.png\",\r\n                animation: \"crouchAttack\",\r\n                instantEffects: function () { \r\n                    this.opponentCard = this.opponent.allUniqueCards[\"turtle\"]\r\n                },\r\n                delayedEffects: function () { } //Instead of their action, your opponent turtles this turn.\r\n            },\r\n\r\n            revengeance: {\r\n                id: \"revengeance\",\r\n                attack: function () { return (this.knight.deckObj.graveyard * 2) + 2 }, // deal damage equal to double the num of cards in discard\r\n                block: function () { return 0 },\r\n                src: \"./dist/art/knight_cards/revengeance.png\",\r\n                animation: \"combo\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            mightyBlow: {\r\n                id: \"mightyBlow\",\r\n                attack: function () { return 8 },\r\n                block: function () { return 0 },\r\n                src: \"./dist/art/knight_cards/mighty_blow.png\",\r\n                animation: \"combo\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            forHonor: {\r\n                id: \"forHonor\",\r\n                attack: function () { return 3 },\r\n                block: function () { return 5 },\r\n                src: \"./dist/art/knight_cards/for_honor.png\",\r\n                animation: \"attack\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { \r\n                    this.numCardsDraw += 1 \r\n                } //draws a card\r\n            },\r\n\r\n            poiseBreak: {\r\n                id: \"poiseBreak\",\r\n                attack: function () { return 4 },\r\n                block: function () { return 0 },\r\n                src: \"./dist/art/knight_cards/poise_break.png\",\r\n                animation: \"crouchAttack\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { \r\n                    this.knight.status[\"opponentPoiseBroken\"] = true\r\n                    this.knight.status[\"ttopponentPoiseBroken\"] = 1\r\n                } // your opponent takes double damage next turn\r\n            },\r\n\r\n            holdTheLine: {\r\n                id: \"holdTheLine\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 10 },\r\n                src: \"./dist/art/knight_cards/hold_the_line.png\",\r\n                animation: \"attack2\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n    opponentCards(opponent) {\r\n        return {\r\n\r\n            strike: {\r\n                id: \"strike\",\r\n                attack: function () { return 6 },\r\n                block: function () { return 0 },\r\n                src: \"./dist/art/opponent_cards/mstrike.png\",\r\n                animation: \"attack\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            rockThrow: {\r\n                id: \"rockThrow\",\r\n                attack: function () { return 8 },\r\n                block: function () { return 6 },\r\n                src: \"./dist/art/opponent_cards/mrock_throw.png\",\r\n                animation: \"attack\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            spikes: {\r\n                id: \"spikes\",\r\n                attack: function () { return 12 },\r\n                block: function () { return 0 },\r\n                src: \"./dist/art/opponent_cards/mspikes.png\",\r\n                animation: \"attack2\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            blindingFlash: {\r\n                id: \"blindingFlash\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 0 },\r\n                src: \"./dist/art/opponent_cards/mblinding_flash.png\",\r\n                animation: \"flash\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { \r\n                    this.knight.status[\"blinded\"] = true\r\n                    this.knight.status[\"ttblinded\"] = 2\r\n                } //You cannot see your opponent’s moves for the next two turns\r\n            },\r\n\r\n            turtle: {\r\n                id: \"turtle\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 4 },\r\n                src: \"./dist/art/opponent_cards/mturtle.png\",\r\n                animation: \"idle\",\r\n                instantEffects: function () { \r\n                    this.opponent.heal(4)\r\n                },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            groundPound: {\r\n                id: \"groundPound\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 0 },\r\n                src: \"./dist/art/opponent_cards/mground_pound.png\",\r\n                animation: \"attack3\",\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { \r\n                    let cardSlots = document.querySelectorAll(\".card-slot\")\r\n                    let filledSlots = this.cardSlotCollector(\"filled\")\r\n\r\n                    if (filledSlots.length) {\r\n                        for (let i = 1; i === 1 && filledSlots.length > 0; i++) {\r\n                            let index = Math.floor(Math.random() * (filledSlots.length));\r\n                            let slotId = filledSlots.splice(index,1)\r\n                            this.clearCardFromSlot(slotId)\r\n                            this.knight.deckObj.graveyard--\r\n                        }\r\n                    }\r\n                } //Destroy a card in player’s hand.\r\n            }\r\n        }\r\n    }   \r\n    thinDeck() {\r\n        let deckSlot = document.getElementById(\"deck-slot\")\r\n        if (this.deck.length === 0) {\r\n            deckSlot.innerHTML = '<img src=\"./dist/art/deck/rune.png\" id=\"deckArt\" width=\"160px\" height=\"260px\"/>'\r\n        } else if (this.deck.length < 3) {\r\n            deckSlot.innerHTML = '<img src=\"' + this.deckObj.emptyDeck.src + '\" id=\"deckArt\" width=\"140px\" height=\"200px\"/>'\r\n        } else if (this.deck.length < 6) {\r\n            deckSlot.innerHTML = '<img src=\"' + this.deckObj.halfDeck.src + '\" id=\"deckArt\" width=\"140px\" height=\"200px\"/>'\r\n        }\r\n    }  \r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://jsproj/./src/deck.js?");

/***/ }),

/***/ "./src/dummy.js":
/*!**********************!*\
  !*** ./src/dummy.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Dummy; }\n/* harmony export */ });\n/* harmony import */ var _combatant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./combatant.js */ \"./src/combatant.js\");\n\r\n\r\nclass Dummy extends _combatant_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n    constructor(spriteWidth, spriteHeight, xPosition, yPosition, sizeCoef) {\r\n        super()\r\n\r\n        this.image = new Image()\r\n        this.image.src = './dist/art/knight1/aIdle.png'\r\n        this.animationState = \"knightIdle\"\r\n        this.spriteWidth = spriteWidth;\r\n        this.spriteHeight = spriteHeight;\r\n        this.xPosition = xPosition\r\n        this.yPosition = yPosition\r\n        this.sizeCoef = sizeCoef\r\n        this.smash = false\r\n\r\n        this.animationStates = [\r\n            { name: \"knightIdle\", frames: 9, src: './dist/art/knight1/aIdle.png' },\r\n            { name: \"knightTIdle\", frames: 9, src: './dist/art/knight1/aIdleTurned.png' },\r\n            { name: \"knightDeath\", frames: 10, src: './dist/art/knight1/aDeath.png' },\r\n            { name: \"knightRun\", frames: 10, src: './dist/art/knight1/aRun.png' },\r\n            { name: \"knighTurn\", frames: 2, src: './dist/art/knight1/aTurnAround.png' },\r\n            { name: \"demonLeap\", frames: 1, src: './dist/art/demon/Leap.png' },\r\n            { name: \"demonSmash\", frames: 1, src: './dist/art/demon/Smash.png' },\r\n            { name: \"demonIdle\", frames: 6, src: './dist/art/demon/Idle.png' },\r\n        ];\r\n\r\n        this.animationFramesSetter()\r\n\r\n    }\r\n\r\n    draw(ctx, gameFrame, staggerFrames, heightOffset) {\r\n        let rawPosition = (gameFrame / staggerFrames) % this.animations[this.animationState].loc.length\r\n        let position = Math.floor(rawPosition)\r\n        let frameX = this.spriteWidth * position;\r\n        let frameY = this.animations[this.animationState].loc[position].y\r\n        ctx.drawImage(this.image, frameX, frameY, this.spriteWidth, this.spriteHeight, this.xPosition, this.yPosition - heightOffset, Math.floor(this.spriteWidth * this.sizeCoef), Math.floor(this.spriteHeight * this.sizeCoef))\r\n    }\r\n\r\n    leap(){\r\n        if (this.xPosition > 300) {\r\n            this.xPosition -= 8\r\n            this.yPosition += 8\r\n        } else {\r\n            this.xPosition = 300\r\n            this.yPosition = 319\r\n            this.smash = true\r\n        }\r\n\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://jsproj/./src/dummy.js?");

/***/ }),

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Game; }\n/* harmony export */ });\n/* harmony import */ var _knight_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./knight.js */ \"./src/knight.js\");\n/* harmony import */ var _opponent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./opponent.js */ \"./src/opponent.js\");\n\r\n\r\n\r\nclass Game {\r\n    constructor(crowd) { \r\n        this.knight = new _knight_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()\r\n        this.opponent = new _opponent_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]()\r\n        this.crowd = crowd\r\n        \r\n        this.numCardsDraw = 0\r\n        this.gameOver = false\r\n        this.gameWin = false\r\n        this.gameLoss = false\r\n        this.cardLoss = false\r\n\r\n        this.playedCard = null\r\n        this.opponentCard = null\r\n    }\r\n        \r\n    setupMat() {\r\n        let deckSlot = document.getElementById(\"deck-slot\")\r\n        deckSlot.innerHTML += '<img src=\"' + this.knight.deckObj.fullDeck.src + '\" id=\"deckArt\" width=\"140px\" height=\"200px\"/>'\r\n        \r\n        let deck = this.knight.deck\r\n        for (let i = 1; i <= 5; i++) {\t\r\n            let card = deck[i - 1]\r\n            let slotId = \"card-slot\" + i\r\n            let slot = document.getElementById(slotId)\r\n            slot.innerHTML += '<img src=\"' + card.src + '\" id=\"' + card.id + '\" class=\"card\" + \" width=\"280px\" height=\"280px\"/>';\r\n        }\r\n\r\n        this.knight.deck = deck.slice(5, deck.length)\r\n    }\r\n\r\n    coreGameLoop(playerCardId, slotId) {\r\n        this.clearCardFromSlot(slotId)\r\n        this.playedCard = this.knight.allUniqueCards[playerCardId]\r\n        this.opponentCard = this.opponent.nextMove[0]\r\n        this.instantCardEffects()\r\n        this.statCalc()\r\n        this.damageCalc()\r\n        this.resolveStatusEffects.call(this.knight, this.knight)\r\n        this.resolveStatusEffects.call(this.opponent, this.opponent)\r\n        this.delayedCardEffects()\r\n\r\n        this.knight.animationQueue.push(this.playedCard.animation)\r\n        this.opponent.animationQueue.push(this.opponentCard.animation)\r\n\r\n        this.gameEndCheck()\r\n        this.crowd.excite(0)\r\n        \r\n        setTimeout(() => {\r\n            this.drawCards()\r\n            this.knight.deckObj.thinDeck.call(this.knight)\r\n            this.opponent.nextMove.shift()\r\n            this.knight.attack = 0\r\n            this.knight.block = 0\r\n            this.opponent.attack = this.opponent.nextMove[0].attack.call(this)\r\n            this.opponent.block = this.opponent.nextMove[0].block.call(this)\r\n            this.playedCard = null\r\n            this.opponentCard = null\r\n        },1100)\r\n    }\r\n\r\n    statCalc() {\r\n        this.knight.attack = this.knight.statusChecker.call(this.knight, this.playedCard.attack.call(this), \"attack\")\r\n        this.knight.block = this.playedCard.block.call(this)\r\n\r\n        this.opponent.attack = this.opponentCard.attack.call(this)\r\n        this.opponent.block = this.opponentCard.block.call(this)\r\n    }\r\n\r\n    gameEndCheck() {\r\n        let i = 0\r\n        while (i === 0) {\r\n            i++\r\n            if (this.knight.health < 1) this.gameLoss = true\r\n            if (this.opponent.health < 1) {\r\n                this.gameWin = true; \r\n                break;\r\n            }\r\n            let emptySlots = this.cardSlotCollector(\"empty\")\r\n            if (emptySlots.length === 5 && this.numCardsDraw === 0) {\r\n                this.gameLoss = true\r\n                this.cardLoss = true\r\n            }\r\n        }\r\n    }\r\n\r\n    damageCalc(){\r\n\r\n        if (this.opponent.attack > this.knight.block && !this.knight.status.damageImmune) {\r\n            this.knight.health -= (this.opponent.attack - this.knight.block)\r\n        }\r\n        if (this.knight.attack > this.opponent.block) {\r\n            this.opponent.health -= (this.knight.attack - this.opponent.block)\r\n            this.numCardsDraw += 1\r\n        }\r\n    }\r\n\r\n    resolveStatusEffects() {\r\n        let statuses = Object.keys(this.status)\r\n        for (let i = 0; i < statuses.length; i++) {\t\r\n            let statusTimerKey = statuses[i]\r\n\r\n            if (statusTimerKey.slice(0, 2) === \"tt\" && this.status[statusTimerKey] > 0) {\r\n                let actualStatusKey = statusTimerKey.slice(2)\r\n                this.status[statusTimerKey] -= 1\r\n                if (this.status[statusTimerKey] === 0) {\r\n                    this.status[actualStatusKey] = false\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    instantCardEffects() {\r\n        this.playedCard.instantEffects.call(this)\r\n        this.opponentCard.instantEffects.call(this)\r\n    }\r\n\r\n    delayedCardEffects(playedCard, opponentCard) {\r\n        this.playedCard.delayedEffects.call(this)\r\n        this.opponentCard.delayedEffects.call(this)\r\n    }\r\n\r\n    clearCardFromSlot(slotId){\r\n        let slot = document.getElementById(slotId)\r\n        slot.innerHTML = \"\"\r\n        this.knight.deckObj.graveyard++\r\n    }\r\n\r\n    addCardtoSlot(slotId) {\r\n        let slot = document.getElementById(slotId)\r\n        if (this.knight.deck.length > 0) {\r\n            let card = this.knight.deck.shift()\r\n            slot.innerHTML += '<img src=\"' + card.src + '\" id=\"' + card.id + '\" class=\"card\" width=\"280px\" height=\"280px\"/>';\r\n        }\r\n    }\r\n\r\n    drawCards() {\r\n        let emptySlots = this.cardSlotCollector(\"empty\")\r\n        for (let i = emptySlots.length - 1; i >= 0 && this.numCardsDraw > 0; this.numCardsDraw--) {\t\r\n            let slotId = emptySlots[Math.abs(i - (emptySlots.length - 1))]\r\n            this.addCardtoSlot(slotId) \r\n            i--\r\n        }\r\n\r\n        this.numCardsDraw = 0\r\n    }\r\n\r\n    cardSlotCollector(filledOrEmpty) {\r\n        let cardSlots = document.querySelectorAll(\".card-slot\")\r\n        let slots = []\r\n        for (let i = 0; i < cardSlots.length; i++) {\r\n            let cardslot = cardSlots[i];\r\n            if (filledOrEmpty === \"empty\") {\r\n                if (!cardslot.firstChild) slots.push(cardslot.id)\r\n            } else {\r\n                if (cardslot.firstChild) slots.push(cardslot.id)\r\n            }\r\n        }\r\n        return slots\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://jsproj/./src/game.js?");

/***/ }),

/***/ "./src/gameView.js":
/*!*************************!*\
  !*** ./src/gameView.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ GameView; }\n/* harmony export */ });\n/* harmony import */ var _game_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game.js */ \"./src/game.js\");\n/* harmony import */ var _crowd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crowd.js */ \"./src/crowd.js\");\n/* harmony import */ var _tutorial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tutorial.js */ \"./src/tutorial.js\");\n/* harmony import */ var _dummy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dummy.js */ \"./src/dummy.js\");\n\r\n\r\n\r\n\r\n\r\nclass GameView {\r\n    constructor(canvas, clientHeight) { \r\n        this.canvas = canvas\r\n        this.ctx = this.canvas.getContext('2d')\r\n        this.pauseInputs = false\r\n\r\n        this.crowd = new _crowd_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]()\r\n        this.crowdArray = this.crowd.crowdArray\r\n\r\n        this.MAX_HEIGHT = 708\r\n        this.MIN_HEIGHT = 578\r\n        \r\n        this.CANVAS_WIDTH = this.canvas.width = 950\r\n        this.setHeight(clientHeight)\r\n        this.screenSize;\r\n        this.setScreenSize(clientHeight)\r\n        \r\n        this.infoDimensions = { infoSquareYOffset: 200, infoSquareXOffset: 274, infoSquareLen: 200, infoSquareHeight: 400 } \r\n        \r\n        this.backgroundImage = new Image()\r\n        this.backgroundImage.src = './dist/art/arena.jpg'\r\n        \r\n        this.matImage = new Image()\r\n        this.matImage.src = './dist/art/mat.png'\r\n        \r\n        this.lossText = new Image()\r\n        this.lossText.src = './dist/art/youded.png'\r\n        \r\n        this.winText = new Image()\r\n        this.winText.src = './dist/art/youwin.png'\r\n        \r\n        this.gameStart = false\r\n        this.tutorialStart = false\r\n        this.playIntroAnimation = false\r\n        this.gameFrame = 0;\r\n        this.staggerFrames = 14;\r\n        \r\n        this.hoveredCard = null\r\n        this.showNextHover = true\r\n        this.showDeckLength = false\r\n        \r\n        this.fadeOut = 0\r\n        this.textFadeIn = 1\r\n        \r\n        this.game = new _game_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.crowd)\r\n        this.knight = this.game.knight\r\n        this.opponent = this.game.opponent\r\n        this.dummy = new _dummy_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](120, 80, 310, 358, 4)\r\n        this.demonDummy = new _dummy_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](500, 400, 919, -300, 1)\r\n\r\n        this.demonDummy.animationState = \"demonLeap\"\r\n        this.demonDummy.image.src = this.dummy.animations[\"demonLeap\"].src\r\n\r\n        this.tutorial = new _tutorial_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.game, this.ctx, this.heightOffset)\r\n        this.titleCard()\r\n        this.introAnimationSeq = 1\r\n\r\n        this.shaking = false\r\n        this.shakeX = 0\r\n        this.shakeY = 0\r\n    }\r\n\r\n    shakeBackground(){\r\n        this.shaking = true\r\n        this.shakeX = Math.floor(Math.random() * 5) - 20\r\n        this.shakeY = Math.floor(Math.random() * 5) - 40\r\n        this.crowd.excite(0)\r\n    }\r\n\r\n    calmBackground() {\r\n        if (this.shaking === true) {\r\n            this.shakeX = 0\r\n            this.shakeY = 0\r\n            this.shaking = false\r\n        }\r\n    }\r\n\r\n    renderIntroAnimation() {\r\n        if (this.introAnimationSeq < 9) {\r\n            this.knight.draw(this.ctx, this.gameFrame, this.staggerFrames, this.heightOffset)\r\n            this.dummy.draw(this.ctx, this.gameFrame, this.staggerFrames, this.heightOffset)\r\n            if (this.introAnimationSeq >= 6) this.demonDummy.draw(this.ctx, this.gameFrame, this.staggerFrames, this.heightOffset)\r\n            if (this.introAnimationSeq === 1) {\r\n                if (this.crowd.excitement >= 75) this.crowd.excite(5)\r\n                if (this.knight.xPosition < 200) {\r\n                    this.knight.runForwards()\r\n                    if (this.knight.animationState === \"idle\"){\r\n                        this.knight.animationQueue.push(\"run\")\r\n                    }\r\n                }  else {\r\n                    this.knight.animationQueue = []\r\n                    this.knight.animationState = \"idle\"\r\n                    this.knight.image.src = this.knight.animations[\"idle\"].src\r\n                    setTimeout(()=>{\r\n                        this.dummy.animationState = \"knightTIdle\"\r\n                        this.dummy.image.src = this.dummy.animations[\"knightTIdle\"].src\r\n                        this.introAnimationSeq = 2\r\n                    },1000)\r\n                }        \r\n            } else if (this.introAnimationSeq === 2) {\r\n                this.ctx.fillStyle = 'rgba(225,225,225,0.9)';\r\n                this.ctx.fillRect(400, 418, 330, 45)\r\n                this.ctx.fillStyle = 'rgba(0,0,0,1)';\r\n                this.ctx.font = \"26px optima, sans-serif \"\r\n                this.ctx.fillText(\"You ready to die today, kid?\", 410, 450, 2000, 200)\r\n                setTimeout(() => {\r\n                    this.introAnimationSeq = 3\r\n                }, 3000)\r\n            } else if (this.introAnimationSeq === 3) {\r\n                this.shakeBackground()\r\n                setTimeout(() => {\r\n                    this.calmBackground()\r\n                    this.introAnimationSeq = 4\r\n                }, 3000)\r\n            } else if (this.introAnimationSeq === 4) {\r\n                    this.ctx.fillStyle = 'rgba(225,225,225,0.9)';\r\n                    this.ctx.fillRect(430, 418, 281, 45)\r\n                    this.ctx.fillStyle = 'rgba(0,0,0,1)';\r\n                    this.ctx.font = \"26px optima, sans-serif \"\r\n                    this.ctx.fillText(\"What the hell was that?\", 440, 450, 2000, 260)\r\n                    setTimeout(() => {\r\n                        this.introAnimationSeq = 5\r\n                    }, 3000)\r\n            } else if (this.introAnimationSeq === 5) {\r\n                this.shakeBackground()\r\n                setTimeout(() => {\r\n                    this.calmBackground()\r\n                    if (this.introAnimationSeq === 5) this.introAnimationSeq = 6\r\n                }, 3000)\r\n            } else if (this.introAnimationSeq === 6) {\r\n                    this.introAnimationSeq = 7\r\n            } else if (this.introAnimationSeq === 7) {\r\n                if (this.knight.animationState = \"idle\") this.knight.animationQueue.push(\"roll\")\r\n                this.demonDummy.leap()\r\n                if (this.demonDummy.smash) {\r\n                    this.crowd.excite(0)\r\n                    this.demonDummy.animationState = \"demonSmash\"\r\n                    this.demonDummy.image.src = this.demonDummy.animations[\"demonSmash\"].src\r\n                    this.dummy.animationState = \"knightDeath\"\r\n                    this.dummy.image.src = this.dummy.animations[\"knightDeath\"].src\r\n                    this.shakeBackground()\r\n                    setTimeout(() => {\r\n                        this.introAnimationSeq = 8\r\n                    }, 300)\r\n                }\r\n            } else if (this.introAnimationSeq === 8) {\r\n                setTimeout(()=>{\r\n                    this.calmBackground()\r\n                },300)\r\n                this.gameStart = true\r\n                this.playIntroAnimation = false\r\n                this.introAnimationSeq = 9\r\n            }\r\n            this.gameFrame++\r\n        }   \r\n    }\r\n\r\n    titleCard() {\r\n        if (!this.gameStart && !this.tutorialStart && !this.playIntroAnimation) {\r\n            this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT)\r\n            this.renderBackground()\r\n            this.renderCrowd()\r\n            this.renderStartOptions()\r\n            requestAnimationFrame(this.titleCard.bind(this))\r\n        } else if (this.tutorialStart) {\r\n            this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT)\r\n            this.renderBackground()\r\n            this.renderCrowd()\r\n            this.tutorial.renderTutorial()\r\n            requestAnimationFrame(this.titleCard.bind(this))\r\n        } else if (this.playIntroAnimation) {\r\n            this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT)\r\n            this.renderBackground()\r\n            this.renderCrowd()\r\n            this.renderIntroAnimation()\r\n            requestAnimationFrame(this.titleCard.bind(this))\r\n        } else if (this.gameStart) {\r\n            this.game.setupMat()\r\n            this.game.knight.xPosition = 200\r\n            this.animate()\r\n        }\r\n    }\r\n\r\n    renderStartOptions() {\r\n        this.ctx.fillStyle = 'rgba(0,0,0,.9)'\r\n        this.ctx.fillRect(-10, 130, 2000, 120)\r\n        this.ctx.fillRect(-10, 290, 2000, 70)\r\n        this.ctx.fillRect(-10, 390, 2000, 70)\r\n        this.ctx.fillStyle = 'rgba(255,87,51,0.35)'\r\n        this.ctx.fillRect(-10,145, 2000, 90)\r\n        this.ctx.fillRect(-10, 305, 2000, 40)\r\n        this.ctx.fillRect(-10, 405, 2000, 40)\r\n\r\n        this.ctx.fillStyle = \"crimson\"\r\n        this.ctx.font = \"130px trattatello, sans-serif \"\r\n        this.ctx.fillText(\"Demon Slayer\", 200, 225)\r\n        this.ctx.font = \"80px trattatello, sans-serif \"\r\n        this.ctx.fillText(\"start\", 260, 350)\r\n        this.ctx.fillText(\"tutorial\", 260, 450)\r\n        \r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(220, 340);\r\n        this.ctx.lineTo(245, 325);\r\n        this.ctx.lineTo(220, 310);\r\n        this.ctx.fill();\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(220, 440);\r\n        this.ctx.lineTo(245, 425);\r\n        this.ctx.lineTo(220, 410);\r\n        this.ctx.fill();\r\n    }\r\n\r\n    renderCrowd() {\r\n\r\n        for (let i = 0; i < this.crowdArray.length; i++) {\r\n            let section = this.crowdArray[i][\"spectArr\"]\r\n            for (let j = 0; j < section.length; j++) {\t\r\n                let spectator = section[j]\r\n                this.ctx.drawImage(spectator[\"img\"], spectator[\"xRender\"], spectator[\"yRender\"], spectator[\"sizeX\"], spectator[\"sizeY\"])\r\n            }\r\n        }\r\n        this.crowd.jostle()\r\n        this.crowd.updateYImmediate(this.heightOffset)\r\n    }\r\n\r\n    animate() {\r\n        \r\n        this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT)\r\n        this.renderBackground()\r\n        this.renderCrowd()\r\n        if (this.game.gameLoss || this.game.gameWin) this.renderGameEndScreen()\r\n        if (!this.game.gameOver) {\r\n            this.renderInfoSquares()\r\n            this.renderText()\r\n            if (this.hoveredCard && this.showNextHover) this.renderHoveredCard(this.hoveredCard)\r\n        }\r\n        this.renderCharacters()\r\n        this.endScreenAnimations()\r\n        this.gameFrame++\r\n\r\n\r\n        requestAnimationFrame(this.animate.bind(this))\r\n    }\r\n\r\n    renderBackground() {\r\n        this.ctx.drawImage(this.backgroundImage, 0, this.heightOffset + 60, 1024 + this.shakeY, this.CANVAS_HEIGHT + this.shakeX, 0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT)\r\n    }\r\n\r\n    renderInfoSquares() {\r\n        this.ctx.fillStyle = 'rgba(225,225,225,0.9)';\r\n        const opponentInfoSquare = this.ctx.fillRect((this.CANVAS_WIDTH - this.infoDimensions.infoSquareXOffset), this.infoDimensions.infoSquareYOffset - this.heightOffset, this.infoDimensions.infoSquareLen, this.infoDimensions.infoSquareHeight)\r\n\r\n        let opponentMove;\r\n        if (this.knight.status[\"blinded\"]) {\r\n            opponentMove = this.opponent.blindedCard.art\r\n        } else {\r\n            opponentMove = this.opponent.nextMove[0].art\r\n        }\r\n        this.ctx.drawImage(opponentMove, (this.CANVAS_WIDTH - this.infoDimensions.infoSquareXOffset) + 10, this.infoDimensions.infoSquareYOffset + 120 - this.heightOffset, 180, 280)\r\n\r\n        const playerInfoSquare = this.ctx.fillRect((this.infoDimensions.infoSquareXOffset - this.infoDimensions.infoSquareLen), this.infoDimensions.infoSquareYOffset - this.heightOffset, this.infoDimensions.infoSquareLen, this.infoDimensions.infoSquareHeight)\r\n    }\r\n\r\n    renderText() {\r\n        this.ctx.fillStyle = 'rgba(0,0,0,1)';\r\n        this.ctx.font = \"26px optima, sans-serif \"\r\n        this.ctx.fillText(\"Monster Health\", (this.CANVAS_WIDTH - this.infoDimensions.infoSquareXOffset) + 14, this.infoDimensions.infoSquareYOffset + 40 - this.heightOffset)\r\n\r\n        if (this.knight.status[\"blinded\"]) {\r\n            this.ctx.fillText(\"Atk: ? Blk: ? \", (this.CANVAS_WIDTH - this.infoDimensions.infoSquareXOffset) + 30, this.infoDimensions.infoSquareYOffset + 110 - this.heightOffset)\r\n            this.ctx.fillText(\"?\", (this.CANVAS_WIDTH - this.infoDimensions.infoSquareXOffset) + 90, this.infoDimensions.infoSquareYOffset + 75 - this.heightOffset)\r\n        } else {\r\n            this.ctx.fillText(`Atk: ${this.opponent.attack} Blk: ${this.opponent.block} `, (this.CANVAS_WIDTH - this.infoDimensions.infoSquareXOffset) + 30, this.infoDimensions.infoSquareYOffset + 110 - this.heightOffset)\r\n            this.ctx.fillText(this.opponent.health, (this.CANVAS_WIDTH - this.infoDimensions.infoSquareXOffset) + 90, this.infoDimensions.infoSquareYOffset + 75 - this.heightOffset)\r\n        }\r\n\r\n        this.ctx.fillText(\"Move\", (this.CANVAS_WIDTH - this.infoDimensions.infoSquareXOffset) + 65, this.infoDimensions.infoSquareYOffset + 150 - this.heightOffset)\r\n\r\n        this.ctx.fillText(\"Knight Health\", (this.infoDimensions.infoSquareXOffset - this.infoDimensions.infoSquareLen) + 21, this.infoDimensions.infoSquareYOffset + 40 - this.heightOffset)\r\n        this.ctx.fillText(`Atk: ${this.knight.attack} Blk: ${this.knight.block} `, (this.infoDimensions.infoSquareXOffset - this.infoDimensions.infoSquareLen) + 30, this.infoDimensions.infoSquareYOffset + 110 - this.heightOffset)\r\n        this.ctx.fillText(this.game.knight.health, (this.infoDimensions.infoSquareXOffset - this.infoDimensions.infoSquareLen) + 81, this.infoDimensions.infoSquareYOffset + 75 - this.heightOffset)\r\n        \r\n        let activeKnightStatus = []\r\n        for (let statusName in this.knight.status) {\r\n            if (statusName.slice(0, 2) === \"tt\" || statusName.slice(0, 2) === \"rr\") {\r\n                continue\r\n            }\r\n            if (this.knight.status[statusName]) {\r\n                activeKnightStatus.push(statusName)\r\n            }\r\n        }\r\n\r\n        let baseline = 160\r\n        if (activeKnightStatus.length) {\r\n            this.ctx.font = \"21px optima, sans-serif \"\r\n\r\n            this.ctx.fillText(\"Status\", (this.infoDimensions.infoSquareXOffset - this.infoDimensions.infoSquareLen) + 30, this.infoDimensions.infoSquareYOffset + 160 - this.heightOffset)\r\n            for (let i = 0; i < activeKnightStatus.length; i++) {\t\r\n                baseline += 30\r\n                let status = this.knight.status[\"rr\" + activeKnightStatus[i]]\r\n                this.ctx.fillText(`${status}`, (this.infoDimensions.infoSquareXOffset - this.infoDimensions.infoSquareLen) + 30, this.infoDimensions.infoSquareYOffset + baseline - this.heightOffset)\r\n\r\n            }\r\n        }\r\n\r\n\r\n        if (this.showDeckLength) {\r\n            this.ctx.fillText(`${this.knight.deck.length} cards left`, 800, 650 - this.heightOffset)\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(850, 660 - this.heightOffset);\r\n            this.ctx.lineTo(870, 680 - this.heightOffset);\r\n            this.ctx.lineTo(890, 660 - this.heightOffset);\r\n            this.ctx.fill();\r\n        }\r\n    }\r\n\r\n    renderCharacters(){\r\n        this.opponent.draw(this.ctx, this.gameFrame, this.staggerFrames, this.heightOffset)\r\n        this.knight.draw(this.ctx, this.gameFrame, this.staggerFrames, this.heightOffset)\r\n\r\n    }\r\n\r\n    endScreenAnimations() {\r\n        if (this.game.gameLoss && this.game.gameWin && !this.game.gameOver) {\r\n            this.staggerFrames = 30\r\n            this.game.gameOver = true\r\n            this.resetAnimationFrames()\r\n            this.knight.animationQueue.push(\"death\")\r\n            this.opponent.animationQueue.push(\"death\")\r\n            this.knight.animationQueue.push(\"dead\")\r\n            this.opponent.animationQueue.push(\"dead\")\r\n        }\r\n        if (this.game.gameLoss && !this.game.gameOver) {\r\n            this.staggerFrames = 30\r\n            this.game.gameOver = true\r\n            this.resetAnimationFrames()\r\n            this.knight.animationQueue.push(\"death\")\r\n            this.knight.animationQueue.push(\"dead\")\r\n        }\r\n        if (this.game.gameWin && !this.game.gameOver) {\r\n            this.staggerFrames = 30\r\n            this.game.gameOver = true\r\n            this.resetAnimationFrames()\r\n            this.opponent.animationQueue.push(\"death\")\r\n            this.opponent.animationQueue.push(\"dead\")\r\n        }\r\n    }\r\n\r\n    resetAnimationFrames() {\r\n        this.gameFrame = 0;\r\n    }\r\n\r\n    renderHoveredCard(cardIdObj) {\r\n        let card;\r\n        if (cardIdObj[\"knightCard\"]) {\r\n            card = this.knight.allUniqueCards[cardIdObj[\"knightCard\"]]\r\n        } else if (this.knight.status[\"blinded\"]) {\r\n            card = this.opponent.blindedCard\r\n        } else {\r\n            card = this.opponent.nextMove[0]\r\n        }\r\n        this.ctx.drawImage(card.art, (this.CANVAS_WIDTH / 2) - 195, (this.CANVAS_HEIGHT / 2) - 450 + this.heightOffset/2, 390, 600)\r\n    }\r\n\r\n    renderGameEndScreen() {\r\n        let text;\r\n        let sizeX;\r\n        let sizeY;\r\n        let posX;\r\n        let posY;\r\n\r\n        if (this.game.gameLoss) {\r\n            text = this.lossText\r\n            sizeX = 600; sizeY = 300; posX = 200; posY = 150 \r\n        } else {\r\n            text = this.winText\r\n            sizeX = 840; sizeY = 220; posX = 80; posY = 150\r\n        }\r\n        this.fadeOut += .01\r\n        this.ctx.fillStyle = `rgba(0,0,0,${this.fadeOut})`;\r\n        this.ctx.fillRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT)\r\n        if (this.fadeOut > 1) {\r\n            this.textFadeIn -= .01\r\n            this.ctx.fillStyle = `rgba(0,0,0,${this.textFadeIn})`;\r\n            this.ctx.drawImage(text, posX, posY - this.heightOffset, sizeX, sizeY)\r\n            this.ctx.fillRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT)\r\n        }\r\n\r\n    }\r\n\r\n\r\n    setScreenSize(clientHeight) {\r\n        \r\n        if (clientHeight < 650) {\r\n            document.body.style.zoom = \"75%\";\r\n            this.screenSize = \"small\"\r\n        } else if (clientHeight < 775 ) {\r\n            document.body.style.zoom = \"85%\";\r\n            this.screenSize = \"medium\"\r\n        } else {\r\n            document.body.style.zoom = \"100%\";\r\n            this.screenSize = \"large\"\r\n        }\r\n    }\r\n\r\n    setHeight(clientHeight) {\r\n        let height;\r\n        if (clientHeight > 950) {\r\n            height = this.MAX_HEIGHT\r\n            this.heightOffset = 0\r\n        } else if (clientHeight < 820) {\r\n            height = this.MIN_HEIGHT\r\n            this.heightOffset = 130\r\n        } else {\r\n            height = clientHeight - 244\r\n            this.heightOffset = 950 - clientHeight\r\n        }\r\n        this.crowd.updateYImmediate(this.heightOffset)\r\n        this.CANVAS_HEIGHT = this.canvas.height = height\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://jsproj/./src/gameView.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _gameView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gameView.js */ \"./src/gameView.js\");\n\n\nconst canvas = document.getElementById('canvas1')\nconst mat = document.getElementById('mat')\nlet clientHeight = document.documentElement.clientHeight\nconst gameview = new _gameView_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](canvas, clientHeight)\n\nmat.addEventListener(\"click\", (e) => {\n    if (!gameview.game.gameOver && !gameview.pauseInputs)  {\n        gameview.showNextHover = false\n        gameview.pauseInputs = true\n        let slot = e.target.parentNode\n        if (slot.className === \"card-slot\") {\n            let playerCardId = e.target.id\n            gameview.resetAnimationFrames()\n            gameview.game.coreGameLoop(playerCardId, slot.id)\n            gameview.hoveredCard = null\n            setTimeout(() => {\n                gameview.pauseInputs = false\n            }, 1500);\n        }\n    }\n});\n\nmat.addEventListener(\"mouseover\", (e) => {\n    let slot = e.target.parentNode\n    if (slot.className === \"card-slot\") {\n        let playerCardId = e.target.id\n        let card = gameview.knight.allUniqueCards[playerCardId]\n\n        gameview.knight.block = card.block.call(gameview.game)\n        gameview.knight.attack = gameview.knight.statusChecker.call(gameview.knight, card.attack.call(gameview.game), \"attack\")\n        gameview.hoveredCard = {knightCard: playerCardId}\n    }\n});\n\nmat.addEventListener(\"mouseout\", (e) => {\n    gameview.showNextHover = true\n    let slot = e.target.parentNode\n    if (slot.className === \"card-slot\") {\n        gameview.hoveredCard = null\n        if (!gameview.pauseInputs) {\n        gameview.knight.attack = 0\n        gameview.knight.block = 0\n        }\n    }\n});\n\ncanvas.addEventListener(\"mousemove\", (e) => {\n    let halfClientMargin = (document.documentElement.clientWidth - gameview.CANVAS_WIDTH)/2\n    if (gameview.gameStart === true) {\n\n\n        if (gameview.screenSize === \"small\") {\n            if (e.clientX > (659 + halfClientMargin) && e.clientX < (745 + halfClientMargin) && e.clientY > (310 - gameview.heightOffset) && e.clientY < (480 - gameview.heightOffset)) {\n                showOpponentCard()\n            } else {\n                gameview.hoveredCard = null\n            }\n        } else if (gameview.screenSize === \"medium\") {\n            if (e.clientX > (683 + halfClientMargin) && e.clientX < (780 + halfClientMargin) && e.clientY > (340 - gameview.heightOffset) && e.clientY < (525 - gameview.heightOffset)) {\n                showOpponentCard()\n            } else {\n                gameview.hoveredCard = null\n            }\n        } else {\n            if (e.clientX > (718 + halfClientMargin) && e.clientX < (840 + halfClientMargin) && e.clientY > (375 - gameview.heightOffset) && e.clientY < (580 - gameview.heightOffset)) {\n                showOpponentCard()\n            } else {\n                gameview.hoveredCard = null\n            }\n        }\n\n    }      \n});\n\n\nconst showOpponentCard = () => {\n    gameview.showNextHover = true\n    if (gameview.knight.status[\"blinded\"]) {\n        gameview.hoveredCard = gameview.opponent.blindedCard\n    } else {\n        gameview.hoveredCard = { opponentCard: gameview.opponent.nextMove.id }\n    }\n}\n\n//numCards in Deck\nmat.addEventListener(\"mouseover\", (e) => {\n    let slot = e.target.parentNode\n    if (slot.id === \"deck-slot\") {\n        gameview.showDeckLength = true\n        gameview.showNextHover = false\n    }\n});\n\nmat.addEventListener(\"mouseout\", (e) => {\n    let slot = e.target.parentNode\n    if (slot.id === \"deck-slot\") {\n        gameview.showDeckLength = false\n        gameview.showNextHover = false\n    }\n});\n\n\n\naddEventListener(\"resize\", (e) => { \n    let clientHeight = document.documentElement.clientHeight\n    gameview.setHeight(clientHeight)\n    gameview.setScreenSize(clientHeight)\n});\n\n\ncanvas.addEventListener(\"click\", (e) => {\n\n    if (!gameview.gameStart || !gameview.playIntroAnimation) {\n        let halfClientMargin = (document.documentElement.clientWidth - gameview.CANVAS_WIDTH) / 2\n\n\n        if (gameview.screenSize === \"small\") {\n            if (e.clientX > (285 + halfClientMargin) && e.clientX < (418 + halfClientMargin) && e.clientY > 236 && e.clientY < 274) {\n                gameview.gameStart = true\n            } else if (e.clientX > (285 + halfClientMargin) && e.clientX < (476 + halfClientMargin) && e.clientY > 313 && e.clientY < 344) {\n                gameview.tutorialStart = true\n            }\n        } else if (gameview.screenSize === \"medium\") {\n            if (e.clientX > (250 + halfClientMargin) && e.clientX < (403 + halfClientMargin) && e.clientY > 274 && e.clientY < 310) {\n                gameview.gameStart = true\n            } else if (e.clientX > (250 + halfClientMargin) && e.clientX < (476 + halfClientMargin) && e.clientY > 360 && e.clientY < 390) {\n                gameview.tutorialStart = true\n            }\n        } else {\n            if (e.clientX > (220 + halfClientMargin) && e.clientX < (400 + halfClientMargin) && e.clientY > 320 && e.clientY < 350) {\n                gameview.gameStart = true\n            } else if (e.clientX > (220 + halfClientMargin) && e.clientX < (425 + halfClientMargin) && e.clientY > 400 && e.clientY < 450) {\n                gameview.tutorialStart = true\n            }\n        }\n\n        if (gameview.tutorialStart) {\n            gameview.tutorial.tutorialSeq += 1\n            if (gameview.tutorial.tutorialSeq === 5) {\n                \n                gameview.playIntroAnimation = true\n                gameview.tutorialStart = false\n\n            }\n        }\n    } \n});\n\n//# sourceURL=webpack://jsproj/./src/index.js?");

/***/ }),

/***/ "./src/knight.js":
/*!***********************!*\
  !*** ./src/knight.js ***!
  \***********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Knight; }\n/* harmony export */ });\n/* harmony import */ var _combatant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./combatant.js */ \"./src/combatant.js\");\n/* harmony import */ var _deck_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./deck.js */ \"./src/deck.js\");\n\r\n\r\n\r\nclass Knight extends _combatant_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n    constructor(){\r\n        super()\r\n        this.name = \"Knight\"\r\n        this.image = new Image()\r\n        this.image.src = './dist/art/knight1/Idle.png'\r\n        this.spriteWidth = 419.5;\r\n        this.spriteHeight = 280;\r\n        this.xPosition = -280\r\n        this.yPosition = 400\r\n        this.sizeCoef = 1\r\n\r\n        this.maxHealth = 30\r\n        this.health = this.maxHealth\r\n\r\n        this.deckObj = new _deck_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, 15)\r\n        this.deck = this.deckObj.stack\r\n        this.allUniqueCards = this.deckObj.allUniqueCards\r\n\r\n        this.animationStates = [\r\n        { name: \"idle\", frames: 10, src: './dist/art/knight1/Idle.png' },\r\n        { name: \"attack\", frames: 5, src: './dist/art/knight1/Attack.png' },\r\n        { name: \"attack2\", frames: 6, src: './dist/art/knight1/Attack2nm.png' },\r\n        { name: \"combo\", frames: 10, src: './dist/art/knight1/AttackCombonm.png' },\r\n        { name: \"death\", frames: 10, src: './dist/art/knight1/Death.png' },\r\n        { name: \"dead\", frames: 1, src: './dist/art/knight1/Dead.png' },\r\n        { name: \"roll\", frames: 12, src: './dist/art/knight1/Roll.png' },\r\n        { name: \"duck\", frames: 3, src: './dist/art/knight1/CrouchAll.png' },\r\n        { name: \"crouchAttack\", frames: 6, src: './dist/art/knight1/CrouchAttack.png' },\r\n        { name: \"hit\", frames: 6, src: './dist/art/knight1/Hit.png' },\r\n        { name: \"run\", frames: 10, src: './dist/art/knight1/Run.png' },\r\n        ];\r\n\r\n        this.animationFramesSetter()\r\n\r\n        this.status = {\r\n            blinded: false,\r\n            ttblinded: 0,\r\n            rrblinded: \"Blinded\",\r\n            opponentPoiseBroken: false,\r\n            ttopponentPoiseBroken: 0,\r\n            rropponentPoiseBroken: \"Double damage\",\r\n            damageImmune: false,\r\n            ttdamageImmune: 0,\r\n            rrdamageImmune: \"Damage immune\"\r\n        }\r\n    }\r\n}\r\n\r\nKnight.prototype.statusChecker = function (unModValue, stat) {\r\n    switch (stat) {\r\n        case \"attack\":\r\n            if (this.status[\"opponentPoiseBroken\"]) return unModValue * 2\r\n        default:\r\n            return unModValue\r\n    }\r\n}\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://jsproj/./src/knight.js?");

/***/ }),

/***/ "./src/opponent.js":
/*!*************************!*\
  !*** ./src/opponent.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Opponent; }\n/* harmony export */ });\n/* harmony import */ var _combatant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./combatant.js */ \"./src/combatant.js\");\n/* harmony import */ var _deck_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./deck.js */ \"./src/deck.js\");\n\r\n\r\n\r\nclass Opponent extends _combatant_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n    constructor() { \r\n        super()\r\n        this.name = \"Opponent\"\r\n        this.image = new Image()\r\n        this.image.src = './dist/art/demon/Idle.png'\r\n        this.spriteWidth = 500;\r\n        this.spriteHeight = 400;\r\n        this.sizeCoef = 1\r\n        this.xPosition = 300\r\n        this.yPosition = 319\r\n        this.animationTripper = -1\r\n        this.animationQueue = []\r\n\r\n        this.deckObj = new _deck_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, 100)\r\n        this.nextMove = this.deckObj.stack\r\n        this.allUniqueCards = this.deckObj.allUniqueCards\r\n\r\n        this.maxHealth = 30\r\n        this.health = this.maxHealth\r\n        this.attack = this.nextMove[0].attack.call(this)\r\n        this.block = this.nextMove[0].block.call(this)\r\n\r\n        this.animationStates = [\r\n        { name: \"idle\", frames: 6, src: './dist/art/demon/Idle.png' },\r\n        { name: \"attack\", frames: 5, src: './dist/art/demon/Attack.png' },\r\n        { name: \"attack2\", frames: 6, src: './dist/art/demon/Attack2.png' },\r\n        { name: \"attack3\", frames: 6, src: './dist/art/demon/Attack3.png' },\r\n        { name: \"hit\", frames: 3, src: './dist/art/demon/Hit.png' },\r\n        { name: \"death\", frames: 4, src: './dist/art/demon/Death.png' },\r\n        { name: \"dead\", frames: 1, src: './dist/art/demon/Dead.png' },\r\n        { name: \"flash\", frames: 6, src: './dist/art/demon/Flash.png' },\r\n        ];\r\n\r\n        this.animationFramesSetter()\r\n\r\n        this.blindedCard = { }\r\n        this.blindedCard[\"art\"] = new Image()\r\n        this.blindedCard.art.src = \"./dist/art/opponent_cards/mblinded.png\"\r\n\r\n        this.status = { }\r\n    }\r\n\r\n\r\n\r\n\r\n}\r\n\r\nOpponent.prototype.animation = function (aniStateName) {\r\n    this.animationState = aniStateName\r\n    this.image.src = this.animations[aniStateName].src\r\n    this.animationTripper = this.framesFinder(aniStateName)\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://jsproj/./src/opponent.js?");

/***/ }),

/***/ "./src/tutorial.js":
/*!*************************!*\
  !*** ./src/tutorial.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Tutorial; }\n/* harmony export */ });\nclass Tutorial {\r\n    constructor(game, ctx, heightOffset) {\r\n        this.ctx = ctx\r\n        this.heightOffset = heightOffset\r\n        this.game = game\r\n        this.panelDrop = 0\r\n        this.knight = new Image()\r\n        this.knight.src = './dist/art/knight1/Idle.png'\r\n        this.leading = 38\r\n        this.archibald = new Image()\r\n        this.archibald.src = './dist/art/knight1/archie.png'\r\n        this.playerCard = new Image()\r\n        this.playerCard.src = './dist/art/knight_cards/strike.png'\r\n        this.opponentCard = new Image()\r\n        this.opponentCard.src = './dist/art/knight_cards/reposition.png'\r\n        this.tutorialSeq = 0\r\n    }\r\n\r\n    renderTutorial() {\r\n        if (this.tutorialSeq === 1) {\r\n            this.renderTutorialPanel1()\r\n        } else if (this.tutorialSeq === 2) {\r\n            this.renderTutorialPanel2()\r\n        } else if (this.tutorialSeq === 3) {\r\n            this.renderTutorialPanel3()\r\n        } else if (this.tutorialSeq === 4) {\r\n            this.renderTutorialPanel4()\r\n        } \r\n    }\r\n\r\n    renderTutorialPanel1() {\r\n        let startLine = 140\r\n        this.ctx.fillStyle = 'rgba(225,225,225,0.9)';\r\n        this.ctx.fillRect(150, 75, 650, this.panelDrop)\r\n        if (this.panelDrop < 400) this.panelDrop += 6.5\r\n        if (this.panelDrop >= 400) {\r\n            this.ctx.drawImage(this.knight, 0, 0, 419.5, 280, 275, 170, 419.5, 280 )\r\n            this.ctx.fillStyle = 'rgba(0,0,0,1)';\r\n            this.ctx.font = \"26px optima, sans-serif \"\r\n            this.ctx.fillText(\"You are\", 200, startLine, 2000, 200)\r\n            this.ctx.font = \"bold 26px optima, sans-serif \"\r\n            this.ctx.fillText(\"Solaire\", 293, startLine, 2000, 200)\r\n            this.ctx.font = \"26px optima, sans-serif \"\r\n            this.ctx.fillText(\", a stalwart knight seeking to\", 370, startLine, 2000, 200)\r\n            this.ctx.fillText(\"prove your worth against the mightiest champions\", 200, startLine += this.leading, 2000, 200)\r\n            this.ctx.fillText(\"of the land. You have come to the Queen\\’s \", 200, startLine += this.leading, 2000, 200)\r\n            this.ctx.fillText(\"tournament at Dragonstone Arena to battle for \", 200, startLine += this.leading, 2000, 200)\r\n            this.ctx.fillText(\"fame and fortune. \", 200, startLine += this.leading, 2000, 200)\r\n        }\r\n    }\r\n\r\n    renderTutorialPanel2() {\r\n        let startLine = 140\r\n        this.ctx.fillStyle = 'rgba(225,225,225,0.9)';\r\n        this.ctx.fillRect(150, 75, 650, 400)\r\n        this.ctx.fillStyle = 'rgba(0,0,0,1)';\r\n        this.ctx.font = \"26px optima, sans-serif\"\r\n        this.ctx.fillText(\"Unfortunately, your first opponent is Sir Archibald,\", 200, startLine, 2000, 200)\r\n        this.ctx.fillText(\"a powerful and deadly knight.\", 200, startLine += this.leading, 2000, 200)\r\n        this.ctx.fillText(\"Defeat is pretty much certain.\", 200, startLine += (this.leading*2), 2000, 200)\r\n        this.ctx.drawImage(this.archibald, 0, 0, 120, 100, 235, 170, 120 * 3.5, 100 * 3.5)\r\n    }\r\n\r\n    renderTutorialPanel3() {\r\n        let startLine = 140\r\n        this.ctx.fillStyle = 'rgba(225,225,225,0.9)';\r\n        this.ctx.fillRect(150, 75, 650, 500)\r\n        this.ctx.fillStyle = 'rgba(0,0,0,1)';\r\n        this.ctx.font = \"bold 26px optima, sans-serif\"\r\n        this.ctx.fillText(\"Core Mechanics\", 200, startLine, 2000, 200)\r\n        this.ctx.font = \"26px optima, sans-serif\"\r\n        this.ctx.fillText(\"The cards represent the moves you can make,\", 200, startLine += this.leading, 2000, 200)\r\n        this.ctx.fillText(\"click on a card to play it.\", 200, startLine += this.leading, 2000, 200)\r\n        this.ctx.fillText(\"Your opponent plays their cards at the same time.\", 200, startLine += this.leading, 2000, 200)\r\n        this.ctx.drawImage(this.playerCard, 340, 245, 130, 200)\r\n        this.ctx.drawImage(this.opponentCard, 480, 245, 130, 200)\r\n        this.ctx.fillText(\"To deal damage, your attack must be higher than\", 200, startLine += (this.leading * 2) + 140, 2000, 200)\r\n        this.ctx.fillText(\"your opponent\\’s block.\", 200, startLine += this.leading, 2000, 200)\r\n    }\r\n\r\n    renderTutorialPanel4() {\r\n        let startLine = 140\r\n        this.ctx.fillStyle = 'rgba(225,225,225,0.9)';\r\n        this.ctx.fillRect(150, 75, 650, 500)\r\n        this.ctx.fillStyle = 'rgba(0,0,0,1)';\r\n        this.ctx.font = \"bold 26px optima, sans-serif\"\r\n        this.ctx.fillText(\"Core Mechanics\", 200, startLine, 2000, 200)\r\n        this.ctx.font = \"26px optima, sans-serif\"\r\n        this.ctx.fillText(\"You draw a card whenever you deal damage.\", 200, startLine += this.leading, 2000, 200)\r\n        this.ctx.fillText(\"Watch out! You die if you run out of cards.\", 200, startLine += this.leading, 2000, 200)\r\n    }\r\n\r\n\r\n\r\n\r\n}\n\n//# sourceURL=webpack://jsproj/./src/tutorial.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;