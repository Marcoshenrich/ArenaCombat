/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/combatant.js":
/*!**************************!*\
  !*** ./src/combatant.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Combatant)\n/* harmony export */ });\nclass Combatant {\n    constructor() {\n        this.animationState = \"idle\"\n        this.animations = [];\n        this.attack = 0\n        this.block = 0\n    }\n\n    animationFramesSetter() {\n        this.animationStates.forEach((spriteState) => {\n            let frames = {\n                loc: [],\n                src: spriteState.src\n            }\n            for (let j = 0; j < spriteState.frames; j++) {\n                let positionX = j * this.spriteWidth;\n                let positionY = 0;\n                frames.loc.push({ x: positionX, y: positionY });\n            }\n            this.animations[spriteState.name] = frames;\n        });\n    }\n\n    draw(ctx, gameFrame, staggerFrames) {\n        let position = Math.floor(gameFrame / staggerFrames) % this.animations[this.animationState].loc.length\n        let frameX = this.spriteWidth * position;\n        let frameY = this.animations[this.animationState].loc[position].y\n        ctx.drawImage(this.image, frameX, frameY, this.spriteWidth, this.spriteHeight, this.xPosition, this.yPosition, Math.floor(this.spriteWidth * 3.5), Math.floor(this.spriteHeight * 3.5))\n    }\n\n    heal(healVal) {\n        if (this.health + healVal > this.maxHealth) {\n            this.health = this.maxHealth\n        } else {\n            this.health += healVal\n        }\n    }\n}\n\n//# sourceURL=webpack://jsproj/./src/combatant.js?");

/***/ }),

/***/ "./src/deck.js":
/*!*********************!*\
  !*** ./src/deck.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Deck)\n/* harmony export */ });\nclass Deck {\r\n    constructor(combatant, decksize) { \r\n        this.combatant = combatant\r\n        this.stack = []\r\n        this.allUniqueCards = {}\r\n        this.deckMaker(decksize)\r\n        this.graveyard = 0\r\n    }\r\n\r\n\r\n    deckMaker(decksize) {\r\n        let infiniteDeck;\r\n        let cardStats;\r\n        if (this.combatant.constructor.name === \"Knight\") {\r\n            cardStats = this.playerCards(this.combatant)\r\n            infiniteDeck = false\r\n        } else {\r\n            cardStats = this.opponentCards(this.combatant)\r\n            infiniteDeck = true\r\n        }\r\n        \r\n        let allCardNames = Object.keys(cardStats)\r\n\r\n        for (let i = 0; i < allCardNames.length; i++) {\r\n            let card = cardStats[allCardNames[i]]\r\n            let img = new Image()\r\n            img.src = card.src\r\n            card.art = img\r\n            this.allUniqueCards[allCardNames[i]] = card\r\n        }\r\n\r\n        for (let i = 0; i < decksize; i++) {\r\n            let card;\r\n            if (infiniteDeck) {\r\n                let allUniqueCardkeys = Object.keys(this.allUniqueCards)\r\n                card = this.allUniqueCards[allUniqueCardkeys[allUniqueCardkeys.length * Math.random() << 0]]\r\n            } else {\r\n                card = this.allUniqueCards[allCardNames[i]]\r\n            }\r\n            this.stack.push(card)\r\n        }\r\n\r\n        this.shuffleDeck()\r\n    }\r\n\r\n    shuffleDeck() {\r\n        for (let i = this.stack.length - 1; i > 0; i--) {\r\n            const j = Math.floor(Math.random() * (i + 1));\r\n            const temp = this.stack[i];\r\n            this.stack[i] = this.stack[j];\r\n            this.stack[j] = temp;\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    playerCards(knight) {\r\n        return {\r\n            strike: {\r\n                id: \"strike\",\r\n                attack: function(){return 3},\r\n                block: function () {return 0},\r\n                src: \"art/knight_cards/strike.png\",\r\n                animation: knight.attackAnimation.bind(knight),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            defend: {\r\n                id: \"defend\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 5 },\r\n                src: \"art/knight_cards/defend.png\",\r\n                animation: knight.attack2Animation.bind(knight),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            reposition: {\r\n                id: \"reposition\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 2 },\r\n                src: \"art/knight_cards/reposition.png\",\r\n                animation: knight.duckAnimation.bind(knight),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { } //draw a card\r\n            },\r\n\r\n            taunt: {\r\n                id: \"taunt\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 4 },\r\n                src: \"art/knight_cards/taunt.png\",\r\n                animation: knight.duckAnimation.bind(knight),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { \r\n                    this.opponent.nextMove[1] = this.opponent.allUniqueCards[\"strike\"]\r\n                } // your opponent must use strike next turn\r\n            },\r\n\r\n            parry: {\r\n                id: \"parry\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 0 },\r\n                src: \"art/knight_cards/parry.png\",\r\n                animation: knight.comboAnimation.bind(knight),\r\n                instantEffects: function (playedCard, opponentCard) {\r\n                    if (opponentCard.attack) {\r\n                        opponentCard.attack = function () { return 0 }\r\n                        this.opponent.health -= 4\r\n                    }\r\n                 },\r\n                delayedEffects: function () { } // If your opponent attacks this turn, you negate the attack and they take 4 damage.\r\n            },\r\n\r\n            shieldOfFaith: {\r\n                id: \"shieldOfFaith\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 5 },\r\n                src: \"art/knight_cards/shield_of_faith.png\",\r\n                animation: knight.attack2Animation.bind(knight),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { \r\n                    this.knight.status[\"damageImmune\"] = true\r\n                    this.knight.status[\"ttdamageImmune\"] = 1\r\n                } //You take no damage next turn\r\n            },\r\n\r\n            dodge: {\r\n                id: \"dodge\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 0 },\r\n                src: \"art/knight_cards/dodge.png\",\r\n                animation: knight.rollAnimation.bind(knight),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { \r\n                    if (this.opponent.attack > this.knight.block) this.knight.health += (this.opponent.attack - this.knight.block)\r\n                } //You take no damage this turn\r\n            },\r\n\r\n            secondWind: {\r\n                id: \"secondWind\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 8 },\r\n                src: \"art/knight_cards/second_wind.png\",\r\n                animation: knight.duckAnimation.bind(knight),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { } //recover 8 health, draw a card\r\n            },\r\n\r\n            feint: {\r\n                id: \"feint\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 0 },\r\n                src: \"art/knight_cards/feint.png\",\r\n                animation: knight.crouchAttackAnimation.bind(knight),\r\n                instantEffects: function () { \r\n                    this.opponentCard = this.opponent.allUniqueCards[\"turtle\"]\r\n                },\r\n                delayedEffects: function () { } //Instead of their action, your opponent turtles this turn.\r\n            },\r\n\r\n            revengeance: {\r\n                id: \"revengeance\",\r\n                attack: function () { return this.knight.deckObj.graveyard * 2 }, // deal damage equal to double the num of cards in discard\r\n                block: function () { return 0 },\r\n                src: \"art/knight_cards/revengeance.png\",\r\n                animation: knight.comboAnimation.bind(knight),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            mightyBlow: {\r\n                id: \"mightyBlow\",\r\n                attack: function () { return 7 },\r\n                block: function () { return 0 },\r\n                src: \"art/knight_cards/mighty_blow.png\",\r\n                animation: knight.comboAnimation.bind(knight),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            forHonor: {\r\n                id: \"forHonor\",\r\n                attack: function () { return 3 },\r\n                block: function () { return 5 },\r\n                src: \"art/knight_cards/for_honor.png\",\r\n                animation: knight.attackAnimation.bind(knight),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { } //draws a card\r\n            },\r\n\r\n            poiseBreak: {\r\n                id: \"poiseBreak\",\r\n                attack: function () { return 4 },\r\n                block: function () { return 0 },\r\n                src: \"art/knight_cards/poise_break.png\",\r\n                animation: knight.crouchAttackAnimation.bind(knight),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { \r\n                    this.knight.status[\"opponentPoiseBroken\"] = true\r\n                    this.knight.status[\"ttopponentPoiseBroken\"] = 1\r\n                } // your opponent takes double damage next turn\r\n            },\r\n\r\n            holdTheLine: {\r\n                id: \"holdTheLine\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 10 },\r\n                src: \"art/knight_cards/hold_the_line.png\",\r\n                animation: knight.attack2Animation.bind(knight),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n    opponentCards(opponent) {\r\n        return {\r\n\r\n            strike: {\r\n                id: \"strike\",\r\n                attack: function () { return 8 },\r\n                block: function () { return 0 },\r\n                src: \"art/opponent_cards/mstrike.png\",\r\n                animation: opponent.attackAnimation.bind(opponent),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            rockThrow: {\r\n                id: \"rockThrow\",\r\n                attack: function () { return 8 },\r\n                block: function () { return 6 },\r\n                src: \"art/opponent_cards/mrock_throw.png\",\r\n                animation: opponent.attacktwiceAnimation.bind(opponent),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            spikes: {\r\n                id: \"spikes\",\r\n                attack: function () { return 12 },\r\n                block: function () { return 0 },\r\n                src: \"art/opponent_cards/mspikes.png\",\r\n                animation: opponent.attack2Animation.bind(opponent),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            blindingFlash: {\r\n                id: \"blindingFlash\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 0 },\r\n                src: \"art/opponent_cards/mblinding_flash.png\",\r\n                animation: opponent.attack3Animation.bind(opponent), \r\n                instantEffects: function () { },\r\n                delayedEffects: function () { \r\n                    this.knight.status[\"blinded\"] = true\r\n                    this.knight.status[\"ttblinded\"] = 2\r\n                } //You cannot see your opponent’s moves for the next two turns\r\n            },\r\n\r\n            turtle: {\r\n                id: \"turtle\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 4 },\r\n                src: \"art/opponent_cards/mturtle.png\",\r\n                animation: opponent.idleAnimation.bind(opponent),\r\n                instantEffects: function () { \r\n                    this.opponent.heal.call(this.opponent, 10)\r\n                },\r\n                delayedEffects: function () { }\r\n            },\r\n\r\n            groundPound: {\r\n                id: \"groundPound\",\r\n                attack: function () { return 0 },\r\n                block: function () { return 0 },\r\n                src: \"art/opponent_cards/mground_pound.png\",\r\n                animation: opponent.attack3Animation.bind(opponent),\r\n                instantEffects: function () { },\r\n                delayedEffects: function () { } //Destroy two cards in player’s hand.\r\n            }\r\n        }\r\n    }   \r\n}\r\n\r\n//player draws cards\r\n//player forces opponent to Strike next turn\r\n//player forces opponent to Block this turn\r\n//player negates attack and deals damage (if opponent attacked)\r\n//player negates damage on next turn\r\n//player negates damage this turn\r\n//player heals\r\n//player tracks number of cards in discard pile and increase damage value\r\n//player forces opponent to take double damage on the following turn\r\n\r\n\r\n//opponent can prevent player from seeing the next move for two turns\r\n//opponet can destroy cards in player's hands. \n\n//# sourceURL=webpack://jsproj/./src/deck.js?");

/***/ }),

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _knight_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./knight.js */ \"./src/knight.js\");\n/* harmony import */ var _opponent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./opponent.js */ \"./src/opponent.js\");\n\r\n\r\n\r\nclass Game {\r\n    constructor() { \r\n        this.knight = new _knight_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()\r\n        this.opponent = new _opponent_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]()\r\n        this.setupMat()\r\n        this.gameOver = false\r\n        this.gameLoss = false\r\n        this.gameWin = false\r\n    }\r\n\r\n    setupMat() {\r\n        let deck = this.knight.deck\r\n\r\n        for (let i = 1; i <= 5; i++) {\t\r\n            let card = deck[i - 1]\r\n            let slotId = \"card-slot\" + i\r\n            let slot = document.getElementById(slotId)\r\n            slot.innerHTML += '<img src=\"' + card.src + '\" id=\"' + card.id + '\" class=\"card\" + \" width=\"280px\" height=\"280px\"/>';\r\n\r\n        }\r\n\r\n        this.knight.deck = deck.slice(5, deck.length)\r\n    }\r\n\r\n    coreGameLoop(playerCardId, slotId) {\r\n        this.clearCardFromSlot(slotId)\r\n        // which have children?\r\n\r\n        let playedCard = this.knight.allUniqueCards[playerCardId]\r\n        let opponentCard = this.opponent.nextMove[0]\r\n\r\n        this.instantCardEffects(playedCard, opponentCard)\r\n\r\n        this.knight.attack = this.knight.statusChecker.call(this.knight, playedCard.attack.call(this), \"attack\")\r\n        this.knight.block = playedCard.block.call(this)\r\n\r\n        this.opponent.attack = opponentCard.attack.call(this)\r\n        this.opponent.block = opponentCard.block.call(this)\r\n\r\n        this.damageCalc()\r\n        \r\n        this.resolveStatusEffects.call(this.knight, this.knight)\r\n        this.resolveStatusEffects.call(this.opponent, this.opponent)\r\n        \r\n        this.delayedCardEffects(playedCard, opponentCard)\r\n\r\n        playedCard.animation()\r\n        opponentCard.animation()\r\n\r\n        setTimeout(() => {\r\n            this.gameEndCheck()\r\n            this.addCardtoSlot(slotId)\r\n            this.opponent.nextMove.shift()\r\n            this.knight.attack = 0\r\n            this.knight.block = 0\r\n            this.opponent.attack = this.opponent.nextMove[0].attack.call(this)\r\n            this.opponent.block = this.opponent.nextMove[0].block.call(this)\r\n        },1100) //should match the pause interval in indexlisteners\r\n    }\r\n\r\n    gameEndCheck() {\r\n        if (this.knight.health < 1) this.gameLoss = true\r\n        if (this.opponent.health < 1) this.gameWin = true\r\n    }\r\n\r\n    damageCalc(){\r\n\r\n        if (this.opponent.attack > this.knight.block && !this.knight.status.damageImmune) {\r\n            this.knight.health -= (this.opponent.attack - this.knight.block)\r\n        }\r\n        if (this.knight.attack > this.opponent.block) {\r\n            this.opponent.health -= (this.knight.attack - this.opponent.block)\r\n        }\r\n    }\r\n\r\n    resolveStatusEffects() {\r\n        let statuses = Object.keys(this.status)\r\n        for (let i = 0; i < statuses.length; i++) {\t\r\n            let statusTimerKey = statuses[i]\r\n\r\n            if (statusTimerKey.slice(0, 2) === \"tt\" && this.status[statusTimerKey] > 0) {\r\n                let actualStatusKey = statusTimerKey.slice(2)\r\n                this.status[statusTimerKey] -= 1\r\n                if (this.status[statusTimerKey] === 0) {\r\n                    this.status[actualStatusKey] = false\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    instantCardEffects(playedCard, opponentCard) {\r\n        playedCard.instantEffects.call(this, playedCard, opponentCard)\r\n        opponentCard.instantEffects.call(this, playedCard, opponentCard)\r\n    }\r\n\r\n    delayedCardEffects(playedCard, opponentCard) {\r\n        playedCard.delayedEffects.call(this, playedCard, opponentCard)\r\n        opponentCard.delayedEffects.call(this, playedCard, opponentCard)\r\n    }\r\n\r\n    clearCardFromSlot(slotId){\r\n        let slot = document.getElementById(slotId)\r\n        slot.innerHTML = \"\"\r\n        this.knight.deckObj.graveyard++\r\n    }\r\n\r\n    addCardtoSlot(slotId) {\r\n        let slot = document.getElementById(slotId)\r\n        if (this.knight.deck.length > 0) {\r\n            let card = this.knight.deck.shift()\r\n            slot.innerHTML += '<img src=\"' + card.src + '\" id=\"' + card.id + '\" class=\"card\" width=\"280px\" height=\"280px\"/>';\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\n\n//# sourceURL=webpack://jsproj/./src/game.js?");

/***/ }),

/***/ "./src/gameView.js":
/*!*************************!*\
  !*** ./src/gameView.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GameView)\n/* harmony export */ });\n/* harmony import */ var _game_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game.js */ \"./src/game.js\");\n\r\n\r\nclass GameView {\r\n    constructor(canvas) { \r\n        this.ctx = canvas.getContext('2d')\r\n        this.pauseInputs = false\r\n\r\n        this.CANVAS_WIDTH = canvas.width = 1024\r\n        this.CANVAS_HEIGHT = canvas.height = 760\r\n        this.infoDimensions = { infoSquareYOffset: 200, infoSquareXOffset: 274, infoSquareLen: 200, infoSquareHeight: 400 } \r\n\r\n        this.backgroundImage = new Image()\r\n        this.backgroundImage.src = 'art/arena.jpg'\r\n\r\n        this.matImage = new Image()\r\n        this.matImage.src = 'art/mat.png'\r\n\r\n        this.lossText = new Image()\r\n        this.lossText.src = 'art/youded.png'\r\n\r\n        this.winText = new Image()\r\n        this.winText.src = 'art/youwin.png'\r\n\r\n        this.game = new _game_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()\r\n        this.knight = this.game.knight\r\n        this.opponent = this.game.opponent\r\n\r\n        this.gameFrame = 0;\r\n        this.staggerFrames = 10;\r\n\r\n        this.animate()\r\n\r\n        this.hoveredCard = null\r\n        this.showNextHover = true\r\n        this.fadeOut = 0\r\n        this.textFadeIn = 1\r\n    }\r\n\r\n    animate() {\r\n        this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT)\r\n        this.renderBackground()\r\n        if (!this.game.gameOver) {\r\n            this.renderInfoSquares()\r\n            this.renderText()\r\n            if (this.hoveredCard && this.showNextHover) this.renderHoveredCard(this.hoveredCard)\r\n        }\r\n        if (this.game.gameLoss || this.game.gameWin) this.renderGameEndScreen()\r\n        this.renderCharacters()\r\n        this.gameFrame++\r\n\r\n\r\n        requestAnimationFrame(this.animate.bind(this))\r\n    }\r\n\r\n    renderBackground() {\r\n        this.ctx.drawImage(this.backgroundImage, 0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT)\r\n\r\n    }\r\n\r\n    renderInfoSquares() {\r\n        this.ctx.fillStyle = 'rgba(225,225,225,0.9)';\r\n        const opponentInfoSquare = this.ctx.fillRect((this.CANVAS_WIDTH - this.infoDimensions.infoSquareXOffset), this.infoDimensions.infoSquareYOffset, this.infoDimensions.infoSquareLen, this.infoDimensions.infoSquareHeight)\r\n\r\n        let opponentMove;\r\n        if (this.knight.status[\"blinded\"]) {\r\n            opponentMove = this.opponent.blindedCard.art\r\n        } else {\r\n            opponentMove = this.opponent.nextMove[0].art\r\n        }\r\n        this.ctx.drawImage(opponentMove, (this.CANVAS_WIDTH - this.infoDimensions.infoSquareXOffset) + 10, this.infoDimensions.infoSquareYOffset + 120, 180, 280)\r\n\r\n        const playerInfoSquare = this.ctx.fillRect((this.infoDimensions.infoSquareXOffset - this.infoDimensions.infoSquareLen), this.infoDimensions.infoSquareYOffset, this.infoDimensions.infoSquareLen, this.infoDimensions.infoSquareHeight)\r\n    }\r\n\r\n    renderText() {\r\n        this.ctx.fillStyle = 'rgba(0,0,0,1)';\r\n        this.ctx.font = \"bold 20px verdana, sans-serif \"\r\n        this.ctx.fillText(\"Monster Health\", (this.CANVAS_WIDTH - this.infoDimensions.infoSquareXOffset) + 14, this.infoDimensions.infoSquareYOffset + 40)\r\n        this.ctx.fillText(`Atk: ${this.opponent.attack} Blk: ${this.opponent.block} `, (this.CANVAS_WIDTH - this.infoDimensions.infoSquareXOffset) +30, this.infoDimensions.infoSquareYOffset + 110)\r\n\r\n        this.ctx.fillText(\"Move\", (this.CANVAS_WIDTH - this.infoDimensions.infoSquareXOffset) + 65, this.infoDimensions.infoSquareYOffset + 140)\r\n        this.ctx.fillText(this.opponent.health, (this.CANVAS_WIDTH - this.infoDimensions.infoSquareXOffset) + 80, this.infoDimensions.infoSquareYOffset + 80)\r\n\r\n        this.ctx.fillText(\"Knight Health\", (this.infoDimensions.infoSquareXOffset - this.infoDimensions.infoSquareLen) + 21, this.infoDimensions.infoSquareYOffset + 40)\r\n        this.ctx.fillText(`Atk: ${this.knight.attack} Blk: ${this.knight.block} `, (this.infoDimensions.infoSquareXOffset - this.infoDimensions.infoSquareLen) + 30, this.infoDimensions.infoSquareYOffset + 110)\r\n        this.ctx.fillText(this.game.knight.health, (this.infoDimensions.infoSquareXOffset - this.infoDimensions.infoSquareLen) + 81, this.infoDimensions.infoSquareYOffset + 80)\r\n        \r\n    }\r\n\r\n    renderCharacters(){\r\n        this.opponent.draw(this.ctx, this.gameFrame, this.staggerFrames)\r\n        this.knight.draw(this.ctx, this.gameFrame, this.staggerFrames)\r\n        if (this.game.gameLoss && !this.game.gameOver) {\r\n            this.game.gameOver = true\r\n            this.resetAnimationFrames()\r\n            this.knight.deathAnimation()\r\n        }\r\n    }\r\n\r\n    resetAnimationFrames() {\r\n        this.gameFrame = 0;\r\n    }\r\n\r\n    renderHoveredCard(cardIdObj) {\r\n        let card;\r\n        if (cardIdObj[\"knightCard\"]) {\r\n            card = this.knight.allUniqueCards[cardIdObj[\"knightCard\"]]\r\n        } else if (this.knight.status[\"blinded\"]) {\r\n            card = this.opponent.blindedCard\r\n        } else {\r\n            card = this.opponent.nextMove[0]\r\n        }\r\n        this.ctx.drawImage(card.art, (this.CANVAS_WIDTH / 2) - (390 / 2), (this.CANVAS_HEIGHT / 2) - (800/2), 390, 600)\r\n    }\r\n\r\n    renderGameEndScreen() {\r\n        let text;\r\n        let sizeX;\r\n        let sizeY;\r\n        let posX;\r\n        let posY;\r\n\r\n        if (this.game.gameLoss) {\r\n            text = this.lossText\r\n            sizeX = 600; sizeY = 300; posX = 200; posY = 150\r\n        } else {\r\n            text = this.winText\r\n            sizeX = 840; sizeY = 220; posX = 80; posY = 150\r\n        }\r\n        this.fadeOut += .01\r\n        this.ctx.fillStyle = `rgba(0,0,0,${this.fadeOut})`;\r\n        this.ctx.fillRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT)\r\n        if (this.fadeOut > 1) {\r\n            this.textFadeIn -= .01\r\n            this.ctx.fillStyle = `rgba(0,0,0,${this.textFadeIn})`;\r\n            this.ctx.drawImage(text, posX, posY, sizeX, sizeY)\r\n            this.ctx.fillRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT)\r\n        }\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://jsproj/./src/gameView.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _gameView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gameView.js */ \"./src/gameView.js\");\n\n\nconst canvas = document.getElementById('canvas1')\nconst mat = document.getElementById('mat')\nconst gameview = new _gameView_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](canvas)\n\nmat.addEventListener(\"click\", (e) => {\n    if (!gameview.pauseInputs) {\n    gameview.showNextHover = false\n    gameview.pauseInputs = true\n    let slot = e.target.parentNode\n    if (slot.className === \"card-slot\") {\n        let playerCardId = e.target.id\n        gameview.resetAnimationFrames()\n        gameview.game.coreGameLoop(playerCardId, slot.id)\n        gameview.hoveredCard = null\n        setTimeout(() => {\n            gameview.pauseInputs = false\n        }, 1500); // this needs to equal the longest animation time. \n    }\n}\n});\n\nmat.addEventListener(\"mouseover\", (e) => {\n    let slot = e.target.parentNode\n    if (slot.className === \"card-slot\") {\n        let playerCardId = e.target.id\n        let card = gameview.knight.allUniqueCards[playerCardId]\n\n        gameview.knight.block = card.block.call(gameview.game)\n        gameview.knight.attack = gameview.knight.statusChecker.call(gameview.knight, card.attack.call(gameview.game), \"attack\")\n        gameview.hoveredCard = {knightCard: playerCardId}\n    }\n});\n\nmat.addEventListener(\"mouseout\", (e) => {\n    gameview.showNextHover = true\n    let slot = e.target.parentNode\n    if (slot.className === \"card-slot\") {\n        gameview.hoveredCard = null\n        if (!gameview.pauseInputs) {\n        gameview.knight.attack = 0\n        gameview.knight.block = 0\n        }\n    }\n});\n\ncanvas.addEventListener(\"mousemove\", (e) => {\n    // gameview.hoveredCard = gameview.opponent.blindedCard\n    if (e.clientX > 800 && e.clientX < 920 && e.clientY > 375 && e.clientY < 580){\n        gameview.showNextHover = true\n        if (gameview.knight.status[\"blinded\"]) {\n            gameview.hoveredCard = gameview.opponent.blindedCard\n        } else {\n            gameview.hoveredCard = { opponentCard: gameview.opponent.nextMove.id }\n        }\n    } else {\n        gameview.showNextHover = false\n    }\n\n\n});\n\n\n//# sourceURL=webpack://jsproj/./src/index.js?");

/***/ }),

/***/ "./src/knight.js":
/*!***********************!*\
  !*** ./src/knight.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Knight)\n/* harmony export */ });\n/* harmony import */ var _combatant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./combatant.js */ \"./src/combatant.js\");\n/* harmony import */ var _deck_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./deck.js */ \"./src/deck.js\");\n\n\n\nclass Knight extends _combatant_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(){\n        super()\n        this.image = new Image()\n        this.image.src = 'art/knight1/_Idle.png'\n        this.spriteWidth = 120;\n        this.spriteHeight = 80;\n        this.xPosition = 200\n        this.yPosition = 450\n\n        this.health = 1\n\n        this.deckObj = new _deck_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, 14)\n        this.deck = this.deckObj.stack\n        this.allUniqueCards = this.deckObj.allUniqueCards\n\n        this.animationStates = [\n        { name: \"idle\", frames: 10, src: 'art/knight1/_Idle.png' },\n        { name: \"attack\", frames: 4, src: 'art/knight1/_Attack.png' },\n        { name: \"attack2\", frames: 6, src: 'art/knight1/_Attack2nm.png' },\n        { name: \"combo\", frames: 10, src: 'art/knight1/_AttackCombonm.png' },\n        { name: \"death\", frames: 10, src: 'art/knight1/_Death.png' },\n        { name: \"dead\", frames: 1, src: 'art/knight1/_Dead.png' },\n        { name: \"roll\", frames: 12, src: 'art/knight1/_Roll.png' },\n        { name: \"duck\", frames: 3, src: 'art/knight1/_CrouchAll.png' },\n        { name: \"crouchAttack\", frames: 6, src: 'art/knight1/_CrouchAttack.png' },\n        { name: \"hit\", frames: 6, src: 'art/knight1/Hit.png' },\n        ];\n\n        this.animationFramesSetter()\n\n        this.status = {\n            blinded: false,\n            ttblinded: 0,\n            opponentPoiseBroken: false,\n            ttopponentPoiseBroken: 0,\n            damageImmune: false,\n            ttdamageImmune: 0\n        }\n    }\n\n\n}\n\nKnight.prototype.statusChecker = function (unModValue, stat) {\n    switch (stat) {\n        case \"attack\":\n            if (this.status[\"opponentPoiseBroken\"]) return unModValue * 2\n        default:\n            return unModValue\n    }\n}\n\nKnight.prototype.idleAnimation = function () {\n    this.animationState = \"idle\"\n    this.image.src = this.animations[\"idle\"].src\n}\n\nKnight.prototype.attackAnimation = function() {\n    this.animationState = \"attack\"\n    this.image.src = this.animations[\"attack\"].src\n\n    setTimeout(() => {\n        this.idleAnimation()\n    }, 830)\n}\n\nKnight.prototype.attack2Animation = function () {\n    this.animationState = \"attack2\"\n    this.image.src = this.animations[\"attack2\"].src\n\n    setTimeout(() => {\n        this.idleAnimation()\n    }, 1000)\n}\n\nKnight.prototype.comboAnimation = function () {\n    this.animationState = \"combo\"\n    this.image.src = this.animations[\"combo\"].src\n\n    setTimeout(() => {\n        this.idleAnimation()\n    }, 1650)\n}\n\nKnight.prototype.deathAnimation = function () {\n    this.animationState = \"death\"\n    this.image.src = this.animations[\"death\"].src\n\n    setTimeout(() => {\n        this.deadAnimation()\n    }, 1650)\n}\n\nKnight.prototype.deadAnimation = function () {\n    this.animationState = \"dead\"\n    this.image.src = this.animations[\"dead\"].src\n}\n\nKnight.prototype.rollAnimation = function () {\n    this.animationState = \"roll\"\n    this.image.src = this.animations[\"roll\"].src\n\n    setTimeout(() => {\n        this.idleAnimation()\n    }, 1830)\n}\n\nKnight.prototype.duckAnimation = function () {\n    this.animationState = \"duck\"\n    this.image.src = this.animations[\"duck\"].src\n\n    setTimeout(() => {\n        this.idleAnimation()\n    }, 650)\n}\n\nKnight.prototype.crouchAttackAnimation = function () {\n    this.animationState = \"crouchAttack\"\n    this.image.src = this.animations[\"crouchAttack\"].src\n\n    setTimeout(() => {\n        this.idleAnimation()\n    }, 1000)\n}\n\n\n//# sourceURL=webpack://jsproj/./src/knight.js?");

/***/ }),

/***/ "./src/opponent.js":
/*!*************************!*\
  !*** ./src/opponent.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Opponent)\n/* harmony export */ });\n/* harmony import */ var _combatant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./combatant.js */ \"./src/combatant.js\");\n/* harmony import */ var _deck_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./deck.js */ \"./src/deck.js\");\n\n\n\nclass Opponent extends _combatant_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor() { \n        super()\n        this.image = new Image()\n        this.image.src = 'art/demon/_Idle.png'\n        this.spriteWidth = 100;\n        this.spriteHeight = 80;\n        this.xPosition = 400\n        this.yPosition = 475\n\n        this.deckObj = new _deck_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, 100)\n        this.nextMove = this.deckObj.stack\n        this.allUniqueCards = this.deckObj.allUniqueCards\n\n        this.maxHealth = 1\n        this.health = this.maxHealth\n        this.attack = this.nextMove[0].attack.call(this)\n        this.block = this.nextMove[0].block.call(this)\n\n        this.animationStates = [\n        { name: \"idle\", frames: 6, src: 'art/demon/_Idle.png' },\n        { name: \"attack\", frames: 5, src: 'art/demon/_Attack.png' },\n        { name: \"attack2\", frames: 6, src: 'art/demon/_Attack2.png' },\n        { name: \"attack3\", frames: 6, src: 'art/demon/_Attack3.png' },\n        { name: \"hit\", frames: 3, src: 'art/demon/_Hit.png' },\n        ];\n\n        this.animationFramesSetter()\n\n        this.blindedCard = {}\n        this.blindedCard[\"art\"] = new Image()\n        this.blindedCard.art.src = \"art/opponent_cards/mblinded.png\"\n\n        this.status = {\n            poiseBreak: false,\n            ttpoiseBreak: 0\n        }\n    }\n\n\n\n\n}\n\nOpponent.prototype.idleAnimation = function () {\n    this.animationState = \"idle\"\n    this.image.src = this.animations[\"idle\"].src\n}\n\nOpponent.prototype.attackAnimation = function () {\n    this.animationState = \"attack\"\n    this.image.src = this.animations[\"attack\"].src\n\n    setTimeout(() => {\n        this.idleAnimation()\n    }, 830)\n}\n\nOpponent.prototype.attacktwiceAnimation = function () {\n    this.animationState = \"attack\"\n    this.image.src = this.animations[\"attack\"].src\n\n    setTimeout(() => {\n        this.idleAnimation()\n    }, 1660)\n}\n\nOpponent.prototype.attack2Animation = function () {\n    this.animationState = \"attack2\"\n    this.image.src = this.animations[\"attack2\"].src\n\n    setTimeout(() => {\n        this.idleAnimation()\n    }, 1000)\n}\n\n\nOpponent.prototype.attack3Animation = function () {\n    this.animationState = \"attack3\"\n    this.image.src = this.animations[\"attack3\"].src\n\n    setTimeout(() => {\n        this.idleAnimation()\n    }, 1000)\n}\n\n\nOpponent.prototype.hitAnimation = function () {\n    this.animationState = \"hit\"\n    this.image.src = this.animations[\"hit\"].src\n\n    setTimeout(() => {\n        this.idleAnimation()\n    }, 500)\n}\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://jsproj/./src/opponent.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;